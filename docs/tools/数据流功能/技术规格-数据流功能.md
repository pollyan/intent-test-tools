# Intent Test Framework 数据流功能 - 技术规格

**文档版本**: 1.0  
**创建日期**: 2025-01-30  
**产品经理**: John  
**受众**: 技术团队、架构师、后端开发、DevOps  

---

## 🏗️ 技术架构概览

### 系统组件
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Frontend      │    │   Backend       │    │  AI Engine     │
│                 │    │                 │    │                 │
│ • React UI      │────│ • Flask API     │────│ • MidSceneJS    │
│ • Smart Input   │    │ • Variable      │    │ • API Methods   │
│ • Form Builder  │    │   Resolver      │    │ • Return Values │
│                 │    │ • Validation    │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Data Layer    │    │  Execution      │    │  Infrastructure │
│                 │    │  Context        │    │                 │
│ • PostgreSQL    │────│ • Memory Store  │    │ • Vercel        │
│ • Variable      │    │ • Session Mgmt  │    │ • Supabase      │
│   Storage       │    │ • Lifecycle     │    │ • Local Proxy   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

---

## 🔧 核心技术需求

### 功能性需求

#### 1. API返回值捕获机制

**支持的Midscene API方法**:
```typescript
interface SupportedAPIs {
  aiQuery: {
    returns: Promise<T>;
    description: "返回结构化数据";
  };
  aiString: {
    returns: Promise<string>;
    description: "返回字符串数据";
  };
  aiNumber: {
    returns: Promise<number>;
    description: "返回数字数据";
  };
  aiBoolean: {
    returns: Promise<boolean>;
    description: "返回布尔值数据";
  };
  aiAsk: {
    returns: Promise<string>;
    description: "返回AI问答结果";
  };
  aiLocate: {
    returns: Promise<{rect: DOMRect, center: Point, scale: number}>;
    description: "返回元素位置信息";
  };
  evaluateJavaScript: {
    returns: Promise<any>;
    description: "返回JS执行结果";
  };
}
```

**实现要求**:
- 动态识别API方法的返回值类型
- 支持Promise异步返回值处理
- 错误情况下的优雅降级
- 返回值的序列化和反序列化

#### 2. 变量存储系统

**数据模型设计**:
```sql
-- 执行上下文变量表
CREATE TABLE execution_contexts (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    execution_id VARCHAR(50) NOT NULL,
    variable_name VARCHAR(255) NOT NULL,
    variable_value TEXT NOT NULL,        -- JSON格式存储
    variable_type ENUM('string', 'number', 'boolean', 'object', 'array'),
    source_step_index INT NOT NULL,
    api_method VARCHAR(100),             -- 来源API方法
    api_params JSON,                     -- API调用参数
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (execution_id) REFERENCES execution_history(execution_id) ON DELETE CASCADE,
    UNIQUE KEY uk_execution_variable (execution_id, variable_name),
    INDEX idx_execution_id (execution_id),
    INDEX idx_variable_name (variable_name),
    INDEX idx_api_method (api_method)
);

-- 扩展步骤执行表
ALTER TABLE step_executions 
ADD COLUMN output_data TEXT COMMENT '步骤输出数据',
ADD COLUMN output_variable VARCHAR(255) COMMENT '输出变量名',
ADD COLUMN output_type VARCHAR(50) COMMENT '输出数据类型';
```

**存储要求**:
- 支持JSON格式的复杂数据存储
- 变量生命周期管理（创建、更新、删除）
- 并发安全的读写操作
- 数据压缩优化（大对象存储）

#### 3. 变量解析引擎

**语法支持规范**:
```typescript
interface VariableSyntax {
  simple: "${variable_name}";           // 简单变量引用
  property: "${object.property}";       // 对象属性访问
  nested: "${user.profile.name}";       // 嵌套属性访问
  array: "${items[0]}";                 // 数组元素访问
  arrayNested: "${users[0].name}";      // 数组对象属性
  negative: "${items[-1]}";             // 负数索引
}
```

**解析器实现要求**:
```python
class VariableResolver:
    def __init__(self, execution_context: ExecutionContext):
        self.context = execution_context
        self.pattern = re.compile(r'\$\{([^}]+)\}')
    
    def resolve_text(self, text: str) -> str:
        """解析文本中的所有变量引用"""
        return self.pattern.sub(self._replace_variable, text)
    
    def _replace_variable(self, match: re.Match) -> str:
        """替换单个变量引用"""
        var_path = match.group(1)
        return self._get_variable_value(var_path)
    
    def _get_variable_value(self, var_path: str) -> str:
        """根据变量路径获取值"""
        # 支持复杂路径解析: object.property[0].field
        pass
    
    def validate_references(self, text: str) -> List[ValidationError]:
        """验证变量引用的有效性"""
        pass
```

### 非功能性需求

#### 1. 性能要求

**响应时间指标**:
| 功能 | 目标时间 | P95时间 | 测量条件 |
|------|----------|---------|----------|
| 智能提示触发 | <100ms | <200ms | 输入`${`后响应 |
| 变量解析处理 | <300ms | <500ms | 包含10个变量 |
| 变量存储操作 | <50ms | <100ms | 单个变量存储 |
| 变量查询操作 | <20ms | <50ms | 按执行ID查询 |

**吞吐量要求**:
- 并发执行支持: 1000+ 测试用例同时执行
- 变量数量支持: 单测试用例100+变量
- 数据大小支持: 单变量最大1MB数据

#### 2. 可靠性要求

**错误处理策略**:
```python
class VariableError(Exception):
    """变量相关错误基类"""
    pass

class VariableNotFoundError(VariableError):
    """变量未找到错误"""
    def __init__(self, variable_name: str):
        self.variable_name = variable_name
        super().__init__(f"Variable '{variable_name}' not found")

class VariablePropertyError(VariableError):
    """变量属性访问错误"""
    def __init__(self, variable_name: str, property_path: str):
        self.variable_name = variable_name
        self.property_path = property_path
        super().__init__(f"Property '{property_path}' not found in variable '{variable_name}'")

class VariableTypeError(VariableError):
    """变量类型错误"""
    pass
```

**数据一致性保证**:
- 事务性操作确保数据完整性
- 变量存储失败时的回滚机制
- 并发访问的锁机制
- 数据备份和恢复策略

#### 3. 扩展性要求

**水平扩展支持**:
- 数据库分片策略（按execution_id分片）
- 缓存层支持（Redis集群）
- 负载均衡配置
- 微服务拆分准备

**垂直扩展优化**:
- 数据库索引优化
- 查询性能调优
- 内存使用优化
- CPU密集型操作优化

---

## 📊 数据流设计

### 执行时数据流
```
步骤执行请求
    ↓
[API方法调用] → MidSceneJS执行 → 返回结果
    ↓
[返回值检查] → 是否有output_variable?
    ↓ (是)
[数据存储] → 序列化数据 → 存储到数据库 → 更新执行上下文
    ↓
[后续步骤] → 参数解析 → 变量引用替换 → 继续执行
```

### 变量生命周期
```
创建阶段: API执行成功 → 返回值捕获 → 类型推断 → 存储
使用阶段: 参数解析 → 变量查找 → 值替换 → 类型转换
清理阶段: 执行完成 → 上下文清理 → 数据归档 → 资源释放
```

---

## 🔌 API接口设计

### 核心API端点

#### 1. 步骤执行API
```typescript
POST /api/v1/executions/{execution_id}/steps
{
  "action": "aiQuery",
  "params": {
    "query": "提取商品信息",
    "dataDemand": "{name: string, price: number}"
  },
  "output_variable": "product_info",
  "step_index": 2,
  "description": "提取商品基本信息"
}

Response:
{
  "success": true,
  "data": {
    "result": {"name": "iPhone", "price": 999},
    "variable": "product_info",
    "dataType": "object",
    "executionTime": "1.2s"
  }
}
```

#### 2. 变量管理API
```typescript
// 获取执行上下文中的所有变量
GET /api/v1/executions/{execution_id}/variables
Response:
{
  "success": true,
  "data": [
    {
      "name": "product_info",
      "type": "object",
      "value": {"name": "iPhone", "price": 999},
      "source_step": 2,
      "api_method": "aiQuery",
      "created_at": "2025-01-30T10:00:00Z"
    }
  ]
}

// 获取特定变量
GET /api/v1/executions/{execution_id}/variables/{variable_name}

// 删除变量
DELETE /api/v1/executions/{execution_id}/variables/{variable_name}
```

#### 3. 智能提示API
```typescript
GET /api/v1/testcases/{testcase_id}/variable-suggestions?step_index=3
Response:
{
  "success": true,
  "data": [
    {
      "name": "product_info",
      "type": "object",
      "properties": ["name", "price"],
      "source_step": 2,
      "description": "商品基本信息"
    },
    {
      "name": "user_data",
      "type": "object", 
      "properties": ["name", "email"],
      "source_step": 1,
      "description": "用户信息"
    }
  ]
}
```

#### 4. 参数验证API
```typescript
POST /api/v1/steps/validate
{
  "step": {
    "action": "ai_input",
    "params": {
      "text": "Hello ${user_name} and ${product_info.price}",
      "locate": "input field"
    }
  },
  "available_variables": ["user_name", "product_info"],
  "execution_context": {...}
}

Response:
{
  "success": true,
  "data": {
    "valid": false,
    "errors": [
      {
        "type": "variable_reference",
        "message": "Variable 'user_age' not found",
        "position": [15, 25],
        "suggestions": ["user_name", "user_email"]
      }
    ],
    "resolved_params": {
      "text": "Hello John and 999",
      "locate": "input field"
    }
  }
}
```

---

## 🖥️ 前端技术规格

### React组件架构

#### 1. SmartVariableInput组件
```typescript
interface SmartVariableInputProps {
  value: string;
  onChange: (value: string) => void;
  availableVariables: Variable[];
  placeholder?: string;
  disabled?: boolean;
  onValidationChange?: (errors: ValidationError[]) => void;
}

interface Variable {
  name: string;
  type: 'string' | 'number' | 'boolean' | 'object' | 'array';
  properties?: string[];
  sourceStep: number;
  description?: string;
  preview?: any;
}

const SmartVariableInput: React.FC<SmartVariableInputProps> = ({
  value,
  onChange,
  availableVariables,
  ...props
}) => {
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [suggestions, setSuggestions] = useState<Variable[]>([]);
  const [selectedIndex, setSelectedIndex] = useState(0);
  
  // 变量语法检测
  const detectVariableReference = useCallback((text: string, cursorPos: number) => {
    const beforeCursor = text.substring(0, cursorPos);
    const match = beforeCursor.match(/\$\{([^}]*)$/);
    return match ? {
      prefix: match[1],
      startPos: match.index + 2,
      isPropertyAccess: match[1].includes('.')
    } : null;
  }, []);
  
  // 智能过滤
  const filterSuggestions = useCallback((prefix: string) => {
    return availableVariables.filter(variable => 
      variable.name.toLowerCase().includes(prefix.toLowerCase()) ||
      variable.description?.toLowerCase().includes(prefix.toLowerCase())
    );
  }, [availableVariables]);
  
  // 事件处理...
  
  return (
    <div className="smart-variable-input">
      <textarea
        value={value}
        onChange={handleInputChange}
        onKeyDown={handleKeyDown}
        {...props}
      />
      {showSuggestions && (
        <VariableSuggestionDropdown
          suggestions={suggestions}
          selectedIndex={selectedIndex}
          onSelect={handleSuggestionSelect}
          onClose={() => setShowSuggestions(false)}
        />
      )}
    </div>
  );
};
```

#### 2. 状态管理策略
```typescript
// 使用Context API管理执行状态
interface ExecutionContextState {
  currentExecution: ExecutionHistory | null;
  variables: Record<string, Variable>;
  availableVariables: Variable[];
  isLoading: boolean;
  errors: ValidationError[];
}

const ExecutionContext = createContext<{
  state: ExecutionContextState;
  actions: {
    loadVariables: (executionId: string) => Promise<void>;
    addVariable: (variable: Variable) => void;
    removeVariable: (variableName: string) => void;
    validateReferences: (text: string) => ValidationError[];
  };
}>({} as any);

// 自定义Hook
const useExecutionContext = () => {
  const context = useContext(ExecutionContext);
  if (!context) {
    throw new Error('useExecutionContext must be used within ExecutionProvider');
  }
  return context;
};
```

### 性能优化策略

#### 1. 组件优化
```typescript
// 使用React.memo防止不必要的重渲染
const SmartVariableInput = React.memo<SmartVariableInputProps>(
  ({ value, onChange, availableVariables, ...props }) => {
    // 组件实现...
  },
  (prevProps, nextProps) => {
    // 自定义比较逻辑，深度比较availableVariables
    return isEqual(prevProps.availableVariables, nextProps.availableVariables) &&
           prevProps.value === nextProps.value;
  }
);

// 使用useMemo缓存昂贵计算
const useVariableSuggestions = (availableVariables: Variable[], searchText: string) => {
  return useMemo(() => {
    if (!searchText) return availableVariables;
    
    return availableVariables
      .filter(variable => 
        variable.name.toLowerCase().includes(searchText.toLowerCase())
      )
      .sort((a, b) => {
        // 按匹配度和使用频率排序
        const aScore = getMatchScore(a.name, searchText);
        const bScore = getMatchScore(b.name, searchText);
        return bScore - aScore;
      });
  }, [availableVariables, searchText]);
};
```

#### 2. 网络优化
```typescript
// 使用SWR进行数据缓存和同步
const useVariables = (executionId: string) => {
  return useSWR(
    executionId ? `/api/v1/executions/${executionId}/variables` : null,
    fetcher,
    {
      refreshInterval: 5000, // 5秒自动刷新
      revalidateOnFocus: true,
      dedupingInterval: 2000, // 2秒内重复请求去重
    }
  );
};

// 防抖处理用户输入
const useDebouncedValidation = (text: string, delay: number = 300) => {
  const [validationResult, setValidationResult] = useState<ValidationResult | null>(null);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      if (text) {
        validateVariableReferences(text).then(setValidationResult);
      }
    }, delay);
    
    return () => clearTimeout(timer);
  }, [text, delay]);
  
  return validationResult;
};
```

---

## 🗄️ 后端技术规格

### Flask应用架构

#### 1. 服务层设计
```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
from dataclasses import dataclass

@dataclass
class Variable:
    name: str
    value: Any
    data_type: str
    source_step: int
    api_method: str
    created_at: datetime

class VariableService(ABC):
    @abstractmethod
    def store_variable(self, execution_id: str, variable: Variable) -> bool:
        pass
    
    @abstractmethod
    def get_variable(self, execution_id: str, variable_name: str) -> Optional[Variable]:
        pass
    
    @abstractmethod
    def get_all_variables(self, execution_id: str) -> List[Variable]:
        pass

class PostgreSQLVariableService(VariableService):
    def __init__(self, db_session):
        self.db = db_session
    
    def store_variable(self, execution_id: str, variable: Variable) -> bool:
        try:
            context = ExecutionContext(
                execution_id=execution_id,
                variable_name=variable.name,
                variable_value=json.dumps(variable.value),
                variable_type=variable.data_type,
                source_step_index=variable.source_step,
                api_method=variable.api_method
            )
            self.db.add(context)
            self.db.commit()
            return True
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to store variable: {e}")
            return False

class VariableResolverService:
    def __init__(self, variable_service: VariableService):
        self.variable_service = variable_service
        self.variable_pattern = re.compile(r'\$\{([^}]+)\}')
    
    def resolve_parameters(self, execution_id: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """解析参数中的变量引用"""
        resolved_params = {}
        
        for key, value in params.items():
            if isinstance(value, str):
                resolved_params[key] = self._resolve_string_value(execution_id, value)
            else:
                resolved_params[key] = value
        
        return resolved_params
    
    def _resolve_string_value(self, execution_id: str, text: str) -> str:
        """解析字符串中的变量引用"""
        def replace_variable(match):
            variable_path = match.group(1)
            return self._get_variable_value(execution_id, variable_path)
        
        return self.variable_pattern.sub(replace_variable, text)
    
    def _get_variable_value(self, execution_id: str, variable_path: str) -> str:
        """根据变量路径获取值"""
        # 解析变量路径: variable_name.property[0].field
        path_parts = self._parse_variable_path(variable_path)
        variable_name = path_parts[0]
        
        variable = self.variable_service.get_variable(execution_id, variable_name)
        if not variable:
            raise VariableNotFoundError(variable_name)
        
        # 遍历属性路径
        current_value = variable.value
        for part in path_parts[1:]:
            current_value = self._access_property(current_value, part, variable_name)
        
        return str(current_value)
```

#### 2. API路由设计
```python
from flask import Blueprint, request, jsonify
from flask_cors import cross_origin

api_v1 = Blueprint('api_v1', __name__, url_prefix='/api/v1')

@api_v1.route('/executions/<execution_id>/steps', methods=['POST'])
@cross_origin()
def execute_step(execution_id):
    """执行测试步骤并捕获返回值"""
    try:
        data = request.get_json()
        action = data.get('action')
        params = data.get('params', {})
        output_variable = data.get('output_variable')
        step_index = data.get('step_index', 0)
        
        # 解析参数中的变量引用
        resolver = VariableResolverService(variable_service)
        resolved_params = resolver.resolve_parameters(execution_id, params)
        
        # 调用MidSceneJS API
        midscene_client = MidSceneClient()
        result = midscene_client.execute_action(action, resolved_params)
        
        # 如果指定了输出变量，存储结果
        if output_variable and result is not None:
            variable = Variable(
                name=output_variable,
                value=result,
                data_type=type(result).__name__.lower(),
                source_step=step_index,
                api_method=action,
                created_at=datetime.utcnow()
            )
            variable_service.store_variable(execution_id, variable)
        
        return jsonify({
            'success': True,
            'data': {
                'result': result,
                'variable': output_variable,
                'resolved_params': resolved_params
            }
        })
        
    except VariableNotFoundError as e:
        return jsonify({
            'success': False,
            'error': {
                'type': 'VARIABLE_NOT_FOUND',
                'message': str(e),
                'variable_name': e.variable_name
            }
        }), 400
        
    except Exception as e:
        logger.error(f"Step execution failed: {e}")
        return jsonify({
            'success': False,
            'error': {
                'type': 'EXECUTION_ERROR',
                'message': str(e)
            }
        }), 500

@api_v1.route('/executions/<execution_id>/variables', methods=['GET'])
@cross_origin()
def get_variables(execution_id):
    """获取执行上下文中的所有变量"""
    try:
        variables = variable_service.get_all_variables(execution_id)
        return jsonify({
            'success': True,
            'data': [var.__dict__ for var in variables]
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500
```

### 性能优化策略

#### 1. 数据库优化
```sql
-- 创建复合索引优化查询性能
CREATE INDEX idx_execution_variables ON execution_contexts(execution_id, variable_name);
CREATE INDEX idx_step_output ON step_executions(execution_id, output_variable);

-- 分区表策略（按日期分区）
CREATE TABLE execution_contexts_2025_01 PARTITION OF execution_contexts
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- 查询优化
EXPLAIN ANALYZE 
SELECT variable_name, variable_value, variable_type 
FROM execution_contexts 
WHERE execution_id = 'exec_123' 
ORDER BY source_step_index;
```

#### 2. 缓存策略
```python
import redis
from functools import wraps

class VariableCacheService:
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.default_ttl = 3600  # 1小时
    
    def get_cached_variables(self, execution_id: str) -> Optional[List[Variable]]:
        """从缓存获取变量列表"""
        cache_key = f"variables:{execution_id}"
        cached_data = self.redis.get(cache_key)
        
        if cached_data:
            variables_data = json.loads(cached_data)
            return [Variable(**data) for data in variables_data]
        
        return None
    
    def cache_variables(self, execution_id: str, variables: List[Variable], ttl: int = None):
        """缓存变量列表"""
        cache_key = f"variables:{execution_id}"
        variables_data = [var.__dict__ for var in variables]
        
        self.redis.setex(
            cache_key, 
            ttl or self.default_ttl,
            json.dumps(variables_data, default=str)
        )

def cache_result(cache_key_func, ttl=3600):
    """缓存装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            cache_key = cache_key_func(*args, **kwargs)
            
            # 尝试从缓存获取
            cached_result = cache_service.get(cache_key)
            if cached_result:
                return json.loads(cached_result)
            
            # 执行函数并缓存结果
            result = func(*args, **kwargs)
            cache_service.setex(cache_key, ttl, json.dumps(result, default=str))
            
            return result
        return wrapper
    return decorator
```

---

## 🧪 测试策略

### 单元测试规范

#### 1. 变量解析器测试
```python
import pytest
from unittest.mock import Mock, patch

class TestVariableResolver:
    def setup_method(self):
        self.mock_variable_service = Mock()
        self.resolver = VariableResolverService(self.mock_variable_service)
    
    def test_simple_variable_resolution(self):
        """测试简单变量解析"""
        # 准备测试数据
        self.mock_variable_service.get_variable.return_value = Variable(
            name='user_name',
            value='John',
            data_type='string',
            source_step=1,
            api_method='aiString',
            created_at=datetime.utcnow()
        )
        
        # 执行测试
        result = self.resolver._resolve_string_value('exec_123', 'Hello ${user_name}!')
        
        # 验证结果
        assert result == 'Hello John!'
        self.mock_variable_service.get_variable.assert_called_once_with('exec_123', 'user_name')
    
    def test_nested_property_access(self):
        """测试嵌套属性访问"""
        # 准备测试数据
        self.mock_variable_service.get_variable.return_value = Variable(
            name='user_data',
            value={'profile': {'name': 'John', 'age': 30}},
            data_type='object',
            source_step=1,
            api_method='aiQuery',
            created_at=datetime.utcnow()
        )
        
        # 执行测试
        result = self.resolver._resolve_string_value('exec_123', 'User: ${user_data.profile.name}')
        
        # 验证结果
        assert result == 'User: John'
    
    def test_variable_not_found_error(self):
        """测试变量未找到错误"""
        self.mock_variable_service.get_variable.return_value = None
        
        with pytest.raises(VariableNotFoundError) as exc_info:
            self.resolver._resolve_string_value('exec_123', '${nonexistent_var}')
        
        assert exc_info.value.variable_name == 'nonexistent_var'
```

#### 2. API端点测试
```python
class TestExecutionAPI:
    def setup_method(self):
        self.app = create_app({'TESTING': True})
        self.client = self.app.test_client()
    
    @patch('api_routes.MidSceneClient')
    @patch('api_routes.variable_service')
    def test_execute_step_with_output_variable(self, mock_variable_service, mock_midscene):
        """测试带输出变量的步骤执行"""
        # 准备测试数据
        mock_midscene.return_value.execute_action.return_value = {
            'name': 'iPhone',
            'price': 999
        }
        mock_variable_service.store_variable.return_value = True
        
        # 发送请求
        response = self.client.post('/api/v1/executions/test_exec/steps', 
            json={
                'action': 'aiQuery',
                'params': {
                    'query': '提取商品信息',
                    'dataDemand': '{name: string, price: number}'
                },
                'output_variable': 'product_info',
                'step_index': 1
            })
        
        # 验证响应
        assert response.status_code == 200
        data = response.get_json()
        assert data['success'] is True
        assert data['data']['variable'] == 'product_info'
        assert data['data']['result']['name'] == 'iPhone'
        
        # 验证服务调用
        mock_variable_service.store_variable.assert_called_once()
```

### 集成测试规范

#### 1. 端到端数据流测试
```python
class TestDataFlowIntegration:
    def setup_method(self):
        self.app = create_test_app()
        self.client = self.app.test_client()
        self.test_execution_id = 'integration_test_' + str(uuid.uuid4())
    
    def test_complete_dataflow_workflow(self):
        """测试完整的数据流工作流"""
        
        # 第一步：执行数据提取
        response1 = self.client.post(f'/api/v1/executions/{self.test_execution_id}/steps',
            json={
                'action': 'aiQuery',
                'params': {
                    'query': '提取商品信息',
                    'dataDemand': '{name: string, price: number}'
                },
                'output_variable': 'product_info',
                'step_index': 1
            })
        
        assert response1.status_code == 200
        assert response1.get_json()['success'] is True
        
        # 第二步：使用提取的数据
        response2 = self.client.post(f'/api/v1/executions/{self.test_execution_id}/steps',
            json={
                'action': 'ai_input',
                'params': {
                    'text': '商品名称：${product_info.name}，价格：${product_info.price}',
                    'locate': '商品信息输入框'
                },
                'step_index': 2
            })
        
        assert response2.status_code == 200
        response_data = response2.get_json()
        assert response_data['success'] is True
        
        # 验证变量解析结果
        resolved_text = response_data['data']['resolved_params']['text']
        assert 'iPhone' in resolved_text
        assert '999' in resolved_text
```

### 性能测试规范

#### 1. 负载测试
```python
import asyncio
import aiohttp
import time

class PerformanceTestSuite:
    async def test_concurrent_variable_resolution(self):
        """测试并发变量解析性能"""
        
        async def single_request():
            async with aiohttp.ClientSession() as session:
                start_time = time.time()
                async with session.post('/api/v1/steps/validate', json={
                    'step': {
                        'action': 'ai_input',
                        'params': {
                            'text': 'Hello ${user_name} with ${product_info.price}'
                        }
                    },
                    'available_variables': ['user_name', 'product_info']
                }) as response:
                    result = await response.json()
                    end_time = time.time()
                    return end_time - start_time, result
        
        # 并发执行100个请求
        tasks = [single_request() for _ in range(100)]
        results = await asyncio.gather(*tasks)
        
        # 分析性能指标
        response_times = [result[0] for result in results]
        avg_time = sum(response_times) / len(response_times)
        p95_time = sorted(response_times)[int(len(response_times) * 0.95)]
        
        # 验证性能要求
        assert avg_time < 0.3  # 平均响应时间 < 300ms
        assert p95_time < 0.5  # P95响应时间 < 500ms
        
        # 验证所有请求成功
        success_count = sum(1 for _, result in results if result.get('success'))
        assert success_count == 100
```

---

## 📈 监控和可观测性

### 性能监控指标

#### 1. 应用性能指标
```python
from prometheus_client import Counter, Histogram, Gauge, start_http_server

# 定义监控指标
VARIABLE_RESOLUTION_DURATION = Histogram(
    'variable_resolution_duration_seconds',
    'Time spent resolving variables',
    ['execution_id', 'variable_count']
)

VARIABLE_STORAGE_OPERATIONS = Counter(
    'variable_storage_operations_total',
    'Total variable storage operations', 
    ['operation', 'status']
)

ACTIVE_EXECUTIONS = Gauge(
    'active_executions_count',
    'Number of active test executions'
)

SMART_SUGGESTIONS_REQUESTS = Counter(
    'smart_suggestions_requests_total',
    'Total smart suggestion requests',
    ['request_type', 'status']
)

# 监控装饰器
def monitor_performance(metric_name: str):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()
            
            try:
                result = func(*args, **kwargs)
                status = 'success'
                return result
            except Exception as e:
                status = 'error'
                raise
            finally:
                duration = time.time() - start_time
                
                if metric_name == 'variable_resolution':
                    VARIABLE_RESOLUTION_DURATION.observe(duration)
                
                # 记录操作计数
                VARIABLE_STORAGE_OPERATIONS.labels(
                    operation=func.__name__,
                    status=status
                ).inc()
        
        return wrapper
    return decorator

# 使用示例
@monitor_performance('variable_resolution')
def resolve_variables(execution_id: str, text: str) -> str:
    # 变量解析逻辑
    pass
```

#### 2. 业务监控指标
```python
# 用户行为指标
USER_ACTIONS = Counter(
    'user_actions_total',
    'Total user actions',
    ['action_type', 'user_type']
)

FEATURE_USAGE = Counter(
    'feature_usage_total', 
    'Feature usage statistics',
    ['feature', 'user_id']
)

ERROR_RATES = Counter(
    'error_rates_total',
    'Error rates by type',
    ['error_type', 'severity']
)

# 业务指标收集
def track_user_action(action_type: str, user_type: str):
    USER_ACTIONS.labels(action_type=action_type, user_type=user_type).inc()

def track_feature_usage(feature: str, user_id: str):
    FEATURE_USAGE.labels(feature=feature, user_id=user_id).inc()
```

### 日志记录规范

#### 1. 结构化日志
```python
import structlog
import logging
from pythonjsonlogger import jsonlogger

# 配置结构化日志
def configure_logging():
    # JSON格式日志
    json_handler = logging.StreamHandler()
    formatter = jsonlogger.JsonFormatter(
        '%(asctime)s %(name)s %(levelname)s %(funcName)s %(lineno)d %(message)s'
    )
    json_handler.setFormatter(formatter)
    
    # 分类日志记录器
    loggers = {
        'dataflow': logging.getLogger('dataflow'),
        'variable_resolution': logging.getLogger('variable_resolution'),
        'api_performance': logging.getLogger('api_performance'),
        'user_behavior': logging.getLogger('user_behavior')
    }
    
    for logger in loggers.values():
        logger.addHandler(json_handler)
        logger.setLevel(logging.INFO)
    
    return loggers

# 使用示例
logger = configure_logging()['dataflow']

def store_variable(execution_id: str, variable: Variable):
    logger.info("Variable storage started", extra={
        'execution_id': execution_id,
        'variable_name': variable.name,
        'variable_type': variable.data_type,
        'data_size': len(str(variable.value))
    })
    
    try:
        # 存储逻辑
        result = perform_storage(variable)
        
        logger.info("Variable storage completed", extra={
            'execution_id': execution_id,
            'variable_name': variable.name,
            'storage_time_ms': result.duration,
            'status': 'success'
        })
        
    except Exception as e:
        logger.error("Variable storage failed", extra={
            'execution_id': execution_id,
            'variable_name': variable.name,
            'error': str(e),
            'error_type': type(e).__name__,
            'status': 'error'
        })
        raise
```

---

## 🔒 安全规范

### 数据安全

#### 1. 变量数据加密
```python
from cryptography.fernet import Fernet
import os
import base64

class VariableEncryption:
    def __init__(self):
        # 从环境变量获取加密密钥
        key = os.getenv('VARIABLE_ENCRYPTION_KEY')
        if not key:
            key = Fernet.generate_key()
            # 在生产环境中，密钥应该存储在安全的密钥管理服务中
        
        self.cipher_suite = Fernet(key)
    
    def encrypt_variable_data(self, data: Any) -> str:
        """加密变量数据"""
        json_data = json.dumps(data, ensure_ascii=False)
        encrypted_data = self.cipher_suite.encrypt(json_data.encode('utf-8'))
        return base64.urlsafe_b64encode(encrypted_data).decode('ascii')
    
    def decrypt_variable_data(self, encrypted_data: str) -> Any:
        """解密变量数据"""
        encrypted_bytes = base64.urlsafe_b64decode(encrypted_data.encode('ascii'))
        decrypted_data = self.cipher_suite.decrypt(encrypted_bytes)
        return json.loads(decrypted_data.decode('utf-8'))
```

#### 2. 访问控制
```python
from functools import wraps
from flask import request, jsonify
import jwt

def require_execution_access(f):
    """验证用户对执行上下文的访问权限"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        execution_id = kwargs.get('execution_id')
        if not execution_id:
            return jsonify({'error': 'Execution ID required'}), 400
        
        # 从请求头获取用户信息
        token = request.headers.get('Authorization', '').replace('Bearer ', '')
        if not token:
            return jsonify({'error': 'Authentication required'}), 401
        
        try:
            payload = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            user_id = payload['user_id']
            
            # 验证用户是否有权限访问该执行
            if not has_execution_access(user_id, execution_id):
                return jsonify({'error': 'Access denied'}), 403
            
            # 将用户信息添加到请求上下文
            request.current_user = payload
            
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
        
        return f(*args, **kwargs)
    
    return decorated_function

def has_execution_access(user_id: str, execution_id: str) -> bool:
    """检查用户是否有权限访问执行上下文"""
    # 查询执行记录的创建者或团队成员
    execution = ExecutionHistory.query.filter_by(execution_id=execution_id).first()
    if not execution:
        return False
    
    return (execution.executed_by == user_id or 
            is_team_member(user_id, execution.team_id))
```

### 输入验证和防护

#### 1. 变量引用安全验证
```python
import re
from typing import List

class VariableSecurityValidator:
    # 安全的变量名模式
    SAFE_VARIABLE_PATTERN = re.compile(r'^[a-zA-Z_][a-zA-Z0-9_]*$')
    # 安全的属性访问模式
    SAFE_PROPERTY_PATTERN = re.compile(r'^[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)*(\[\d+\])*$')
    
    @classmethod
    def validate_variable_reference(cls, variable_path: str) -> bool:
        """验证变量引用路径的安全性"""
        if not variable_path:
            return False
        
        # 检查是否包含危险字符
        dangerous_patterns = [
            r'\.\./',  # 路径遍历
            r'__\w+__',  # Python内置属性
            r'eval|exec|import|open|file',  # 危险函数
            r'<script|javascript:|data:',  # XSS模式
        ]
        
        for pattern in dangerous_patterns:
            if re.search(pattern, variable_path, re.IGNORECASE):
                return False
        
        # 验证路径格式
        return bool(cls.SAFE_PROPERTY_PATTERN.match(variable_path))
    
    @classmethod
    def sanitize_variable_value(cls, value: Any) -> Any:
        """清理变量值，防止XSS等攻击"""
        if isinstance(value, str):
            # HTML转义
            import html
            return html.escape(value)
        elif isinstance(value, dict):
            return {k: cls.sanitize_variable_value(v) for k, v in value.items()}
        elif isinstance(value, list):
            return [cls.sanitize_variable_value(item) for item in value]
        else:
            return value
```

---

**文档状态**: 待技术评审  
**评审人**: 技术负责人、架构师、安全专家  
**下一步**: 基于此技术规格进行详细设计和开发计划制定  

*本文档为技术团队提供详细的实现指导，涵盖架构设计、API规范、性能要求、测试策略和安全规范*