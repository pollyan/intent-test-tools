# Intent Test Framework æ•°æ®æµåŠŸèƒ½ - æŠ€æœ¯è§„æ ¼

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-01-30  
**äº§å“ç»ç†**: John  
**å—ä¼—**: æŠ€æœ¯å›¢é˜Ÿã€æ¶æ„å¸ˆã€åç«¯å¼€å‘ã€DevOps  

---

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„æ¦‚è§ˆ

### ç³»ç»Ÿç»„ä»¶
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Frontend      â”‚    â”‚   Backend       â”‚    â”‚  AI Engine     â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ â€¢ React UI      â”‚â”€â”€â”€â”€â”‚ â€¢ Flask API     â”‚â”€â”€â”€â”€â”‚ â€¢ MidSceneJS    â”‚
â”‚ â€¢ Smart Input   â”‚    â”‚ â€¢ Variable      â”‚    â”‚ â€¢ API Methods   â”‚
â”‚ â€¢ Form Builder  â”‚    â”‚   Resolver      â”‚    â”‚ â€¢ Return Values â”‚
â”‚                 â”‚    â”‚ â€¢ Validation    â”‚    â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Data Layer    â”‚    â”‚  Execution      â”‚    â”‚  Infrastructure â”‚
â”‚                 â”‚    â”‚  Context        â”‚    â”‚                 â”‚
â”‚ â€¢ PostgreSQL    â”‚â”€â”€â”€â”€â”‚ â€¢ Memory Store  â”‚    â”‚ â€¢ Vercel        â”‚
â”‚ â€¢ Variable      â”‚    â”‚ â€¢ Session Mgmt  â”‚    â”‚ â€¢ Supabase      â”‚
â”‚   Storage       â”‚    â”‚ â€¢ Lifecycle     â”‚    â”‚ â€¢ Local Proxy   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ æ ¸å¿ƒæŠ€æœ¯éœ€æ±‚

### åŠŸèƒ½æ€§éœ€æ±‚

#### 1. APIè¿”å›å€¼æ•è·æœºåˆ¶

**æ”¯æŒçš„Midscene APIæ–¹æ³•**:
```typescript
interface SupportedAPIs {
  aiQuery: {
    returns: Promise<T>;
    description: "è¿”å›ç»“æ„åŒ–æ•°æ®";
  };
  aiString: {
    returns: Promise<string>;
    description: "è¿”å›å­—ç¬¦ä¸²æ•°æ®";
  };
  aiNumber: {
    returns: Promise<number>;
    description: "è¿”å›æ•°å­—æ•°æ®";
  };
  aiBoolean: {
    returns: Promise<boolean>;
    description: "è¿”å›å¸ƒå°”å€¼æ•°æ®";
  };
  aiAsk: {
    returns: Promise<string>;
    description: "è¿”å›AIé—®ç­”ç»“æœ";
  };
  aiLocate: {
    returns: Promise<{rect: DOMRect, center: Point, scale: number}>;
    description: "è¿”å›å…ƒç´ ä½ç½®ä¿¡æ¯";
  };
  evaluateJavaScript: {
    returns: Promise<any>;
    description: "è¿”å›JSæ‰§è¡Œç»“æœ";
  };
}
```

**å®ç°è¦æ±‚**:
- åŠ¨æ€è¯†åˆ«APIæ–¹æ³•çš„è¿”å›å€¼ç±»å‹
- æ”¯æŒPromiseå¼‚æ­¥è¿”å›å€¼å¤„ç†
- é”™è¯¯æƒ…å†µä¸‹çš„ä¼˜é›…é™çº§
- è¿”å›å€¼çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–

#### 2. å˜é‡å­˜å‚¨ç³»ç»Ÿ

**æ•°æ®æ¨¡å‹è®¾è®¡**:
```sql
-- æ‰§è¡Œä¸Šä¸‹æ–‡å˜é‡è¡¨
CREATE TABLE execution_contexts (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    execution_id VARCHAR(50) NOT NULL,
    variable_name VARCHAR(255) NOT NULL,
    variable_value TEXT NOT NULL,        -- JSONæ ¼å¼å­˜å‚¨
    variable_type ENUM('string', 'number', 'boolean', 'object', 'array'),
    source_step_index INT NOT NULL,
    api_method VARCHAR(100),             -- æ¥æºAPIæ–¹æ³•
    api_params JSON,                     -- APIè°ƒç”¨å‚æ•°
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (execution_id) REFERENCES execution_history(execution_id) ON DELETE CASCADE,
    UNIQUE KEY uk_execution_variable (execution_id, variable_name),
    INDEX idx_execution_id (execution_id),
    INDEX idx_variable_name (variable_name),
    INDEX idx_api_method (api_method)
);

-- æ‰©å±•æ­¥éª¤æ‰§è¡Œè¡¨
ALTER TABLE step_executions 
ADD COLUMN output_data TEXT COMMENT 'æ­¥éª¤è¾“å‡ºæ•°æ®',
ADD COLUMN output_variable VARCHAR(255) COMMENT 'è¾“å‡ºå˜é‡å',
ADD COLUMN output_type VARCHAR(50) COMMENT 'è¾“å‡ºæ•°æ®ç±»å‹';
```

**å­˜å‚¨è¦æ±‚**:
- æ”¯æŒJSONæ ¼å¼çš„å¤æ‚æ•°æ®å­˜å‚¨
- å˜é‡ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼ˆåˆ›å»ºã€æ›´æ–°ã€åˆ é™¤ï¼‰
- å¹¶å‘å®‰å…¨çš„è¯»å†™æ“ä½œ
- æ•°æ®å‹ç¼©ä¼˜åŒ–ï¼ˆå¤§å¯¹è±¡å­˜å‚¨ï¼‰

#### 3. å˜é‡è§£æå¼•æ“

**è¯­æ³•æ”¯æŒè§„èŒƒ**:
```typescript
interface VariableSyntax {
  simple: "${variable_name}";           // ç®€å•å˜é‡å¼•ç”¨
  property: "${object.property}";       // å¯¹è±¡å±æ€§è®¿é—®
  nested: "${user.profile.name}";       // åµŒå¥—å±æ€§è®¿é—®
  array: "${items[0]}";                 // æ•°ç»„å…ƒç´ è®¿é—®
  arrayNested: "${users[0].name}";      // æ•°ç»„å¯¹è±¡å±æ€§
  negative: "${items[-1]}";             // è´Ÿæ•°ç´¢å¼•
}
```

**è§£æå™¨å®ç°è¦æ±‚**:
```python
class VariableResolver:
    def __init__(self, execution_context: ExecutionContext):
        self.context = execution_context
        self.pattern = re.compile(r'\$\{([^}]+)\}')
    
    def resolve_text(self, text: str) -> str:
        """è§£ææ–‡æœ¬ä¸­çš„æ‰€æœ‰å˜é‡å¼•ç”¨"""
        return self.pattern.sub(self._replace_variable, text)
    
    def _replace_variable(self, match: re.Match) -> str:
        """æ›¿æ¢å•ä¸ªå˜é‡å¼•ç”¨"""
        var_path = match.group(1)
        return self._get_variable_value(var_path)
    
    def _get_variable_value(self, var_path: str) -> str:
        """æ ¹æ®å˜é‡è·¯å¾„è·å–å€¼"""
        # æ”¯æŒå¤æ‚è·¯å¾„è§£æ: object.property[0].field
        pass
    
    def validate_references(self, text: str) -> List[ValidationError]:
        """éªŒè¯å˜é‡å¼•ç”¨çš„æœ‰æ•ˆæ€§"""
        pass
```

### éåŠŸèƒ½æ€§éœ€æ±‚

#### 1. æ€§èƒ½è¦æ±‚

**å“åº”æ—¶é—´æŒ‡æ ‡**:
| åŠŸèƒ½ | ç›®æ ‡æ—¶é—´ | P95æ—¶é—´ | æµ‹é‡æ¡ä»¶ |
|------|----------|---------|----------|
| æ™ºèƒ½æç¤ºè§¦å‘ | <100ms | <200ms | è¾“å…¥`${`åå“åº” |
| å˜é‡è§£æå¤„ç† | <300ms | <500ms | åŒ…å«10ä¸ªå˜é‡ |
| å˜é‡å­˜å‚¨æ“ä½œ | <50ms | <100ms | å•ä¸ªå˜é‡å­˜å‚¨ |
| å˜é‡æŸ¥è¯¢æ“ä½œ | <20ms | <50ms | æŒ‰æ‰§è¡ŒIDæŸ¥è¯¢ |

**ååé‡è¦æ±‚**:
- å¹¶å‘æ‰§è¡Œæ”¯æŒ: 1000+ æµ‹è¯•ç”¨ä¾‹åŒæ—¶æ‰§è¡Œ
- å˜é‡æ•°é‡æ”¯æŒ: å•æµ‹è¯•ç”¨ä¾‹100+å˜é‡
- æ•°æ®å¤§å°æ”¯æŒ: å•å˜é‡æœ€å¤§1MBæ•°æ®

#### 2. å¯é æ€§è¦æ±‚

**é”™è¯¯å¤„ç†ç­–ç•¥**:
```python
class VariableError(Exception):
    """å˜é‡ç›¸å…³é”™è¯¯åŸºç±»"""
    pass

class VariableNotFoundError(VariableError):
    """å˜é‡æœªæ‰¾åˆ°é”™è¯¯"""
    def __init__(self, variable_name: str):
        self.variable_name = variable_name
        super().__init__(f"Variable '{variable_name}' not found")

class VariablePropertyError(VariableError):
    """å˜é‡å±æ€§è®¿é—®é”™è¯¯"""
    def __init__(self, variable_name: str, property_path: str):
        self.variable_name = variable_name
        self.property_path = property_path
        super().__init__(f"Property '{property_path}' not found in variable '{variable_name}'")

class VariableTypeError(VariableError):
    """å˜é‡ç±»å‹é”™è¯¯"""
    pass
```

**æ•°æ®ä¸€è‡´æ€§ä¿è¯**:
- äº‹åŠ¡æ€§æ“ä½œç¡®ä¿æ•°æ®å®Œæ•´æ€§
- å˜é‡å­˜å‚¨å¤±è´¥æ—¶çš„å›æ»šæœºåˆ¶
- å¹¶å‘è®¿é—®çš„é”æœºåˆ¶
- æ•°æ®å¤‡ä»½å’Œæ¢å¤ç­–ç•¥

#### 3. æ‰©å±•æ€§è¦æ±‚

**æ°´å¹³æ‰©å±•æ”¯æŒ**:
- æ•°æ®åº“åˆ†ç‰‡ç­–ç•¥ï¼ˆæŒ‰execution_idåˆ†ç‰‡ï¼‰
- ç¼“å­˜å±‚æ”¯æŒï¼ˆRedisé›†ç¾¤ï¼‰
- è´Ÿè½½å‡è¡¡é…ç½®
- å¾®æœåŠ¡æ‹†åˆ†å‡†å¤‡

**å‚ç›´æ‰©å±•ä¼˜åŒ–**:
- æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–
- æŸ¥è¯¢æ€§èƒ½è°ƒä¼˜
- å†…å­˜ä½¿ç”¨ä¼˜åŒ–
- CPUå¯†é›†å‹æ“ä½œä¼˜åŒ–

---

## ğŸ“Š æ•°æ®æµè®¾è®¡

### æ‰§è¡Œæ—¶æ•°æ®æµ
```
æ­¥éª¤æ‰§è¡Œè¯·æ±‚
    â†“
[APIæ–¹æ³•è°ƒç”¨] â†’ MidSceneJSæ‰§è¡Œ â†’ è¿”å›ç»“æœ
    â†“
[è¿”å›å€¼æ£€æŸ¥] â†’ æ˜¯å¦æœ‰output_variable?
    â†“ (æ˜¯)
[æ•°æ®å­˜å‚¨] â†’ åºåˆ—åŒ–æ•°æ® â†’ å­˜å‚¨åˆ°æ•°æ®åº“ â†’ æ›´æ–°æ‰§è¡Œä¸Šä¸‹æ–‡
    â†“
[åç»­æ­¥éª¤] â†’ å‚æ•°è§£æ â†’ å˜é‡å¼•ç”¨æ›¿æ¢ â†’ ç»§ç»­æ‰§è¡Œ
```

### å˜é‡ç”Ÿå‘½å‘¨æœŸ
```
åˆ›å»ºé˜¶æ®µ: APIæ‰§è¡ŒæˆåŠŸ â†’ è¿”å›å€¼æ•è· â†’ ç±»å‹æ¨æ–­ â†’ å­˜å‚¨
ä½¿ç”¨é˜¶æ®µ: å‚æ•°è§£æ â†’ å˜é‡æŸ¥æ‰¾ â†’ å€¼æ›¿æ¢ â†’ ç±»å‹è½¬æ¢
æ¸…ç†é˜¶æ®µ: æ‰§è¡Œå®Œæˆ â†’ ä¸Šä¸‹æ–‡æ¸…ç† â†’ æ•°æ®å½’æ¡£ â†’ èµ„æºé‡Šæ”¾
```

---

## ğŸ”Œ APIæ¥å£è®¾è®¡

### æ ¸å¿ƒAPIç«¯ç‚¹

#### 1. æ­¥éª¤æ‰§è¡ŒAPI
```typescript
POST /api/v1/executions/{execution_id}/steps
{
  "action": "aiQuery",
  "params": {
    "query": "æå–å•†å“ä¿¡æ¯",
    "dataDemand": "{name: string, price: number}"
  },
  "output_variable": "product_info",
  "step_index": 2,
  "description": "æå–å•†å“åŸºæœ¬ä¿¡æ¯"
}

Response:
{
  "success": true,
  "data": {
    "result": {"name": "iPhone", "price": 999},
    "variable": "product_info",
    "dataType": "object",
    "executionTime": "1.2s"
  }
}
```

#### 2. å˜é‡ç®¡ç†API
```typescript
// è·å–æ‰§è¡Œä¸Šä¸‹æ–‡ä¸­çš„æ‰€æœ‰å˜é‡
GET /api/v1/executions/{execution_id}/variables
Response:
{
  "success": true,
  "data": [
    {
      "name": "product_info",
      "type": "object",
      "value": {"name": "iPhone", "price": 999},
      "source_step": 2,
      "api_method": "aiQuery",
      "created_at": "2025-01-30T10:00:00Z"
    }
  ]
}

// è·å–ç‰¹å®šå˜é‡
GET /api/v1/executions/{execution_id}/variables/{variable_name}

// åˆ é™¤å˜é‡
DELETE /api/v1/executions/{execution_id}/variables/{variable_name}
```

#### 3. æ™ºèƒ½æç¤ºAPI
```typescript
GET /api/v1/testcases/{testcase_id}/variable-suggestions?step_index=3
Response:
{
  "success": true,
  "data": [
    {
      "name": "product_info",
      "type": "object",
      "properties": ["name", "price"],
      "source_step": 2,
      "description": "å•†å“åŸºæœ¬ä¿¡æ¯"
    },
    {
      "name": "user_data",
      "type": "object", 
      "properties": ["name", "email"],
      "source_step": 1,
      "description": "ç”¨æˆ·ä¿¡æ¯"
    }
  ]
}
```

#### 4. å‚æ•°éªŒè¯API
```typescript
POST /api/v1/steps/validate
{
  "step": {
    "action": "ai_input",
    "params": {
      "text": "Hello ${user_name} and ${product_info.price}",
      "locate": "input field"
    }
  },
  "available_variables": ["user_name", "product_info"],
  "execution_context": {...}
}

Response:
{
  "success": true,
  "data": {
    "valid": false,
    "errors": [
      {
        "type": "variable_reference",
        "message": "Variable 'user_age' not found",
        "position": [15, 25],
        "suggestions": ["user_name", "user_email"]
      }
    ],
    "resolved_params": {
      "text": "Hello John and 999",
      "locate": "input field"
    }
  }
}
```

---

## ğŸ–¥ï¸ å‰ç«¯æŠ€æœ¯è§„æ ¼

### Reactç»„ä»¶æ¶æ„

#### 1. SmartVariableInputç»„ä»¶
```typescript
interface SmartVariableInputProps {
  value: string;
  onChange: (value: string) => void;
  availableVariables: Variable[];
  placeholder?: string;
  disabled?: boolean;
  onValidationChange?: (errors: ValidationError[]) => void;
}

interface Variable {
  name: string;
  type: 'string' | 'number' | 'boolean' | 'object' | 'array';
  properties?: string[];
  sourceStep: number;
  description?: string;
  preview?: any;
}

const SmartVariableInput: React.FC<SmartVariableInputProps> = ({
  value,
  onChange,
  availableVariables,
  ...props
}) => {
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [suggestions, setSuggestions] = useState<Variable[]>([]);
  const [selectedIndex, setSelectedIndex] = useState(0);
  
  // å˜é‡è¯­æ³•æ£€æµ‹
  const detectVariableReference = useCallback((text: string, cursorPos: number) => {
    const beforeCursor = text.substring(0, cursorPos);
    const match = beforeCursor.match(/\$\{([^}]*)$/);
    return match ? {
      prefix: match[1],
      startPos: match.index + 2,
      isPropertyAccess: match[1].includes('.')
    } : null;
  }, []);
  
  // æ™ºèƒ½è¿‡æ»¤
  const filterSuggestions = useCallback((prefix: string) => {
    return availableVariables.filter(variable => 
      variable.name.toLowerCase().includes(prefix.toLowerCase()) ||
      variable.description?.toLowerCase().includes(prefix.toLowerCase())
    );
  }, [availableVariables]);
  
  // äº‹ä»¶å¤„ç†...
  
  return (
    <div className="smart-variable-input">
      <textarea
        value={value}
        onChange={handleInputChange}
        onKeyDown={handleKeyDown}
        {...props}
      />
      {showSuggestions && (
        <VariableSuggestionDropdown
          suggestions={suggestions}
          selectedIndex={selectedIndex}
          onSelect={handleSuggestionSelect}
          onClose={() => setShowSuggestions(false)}
        />
      )}
    </div>
  );
};
```

#### 2. çŠ¶æ€ç®¡ç†ç­–ç•¥
```typescript
// ä½¿ç”¨Context APIç®¡ç†æ‰§è¡ŒçŠ¶æ€
interface ExecutionContextState {
  currentExecution: ExecutionHistory | null;
  variables: Record<string, Variable>;
  availableVariables: Variable[];
  isLoading: boolean;
  errors: ValidationError[];
}

const ExecutionContext = createContext<{
  state: ExecutionContextState;
  actions: {
    loadVariables: (executionId: string) => Promise<void>;
    addVariable: (variable: Variable) => void;
    removeVariable: (variableName: string) => void;
    validateReferences: (text: string) => ValidationError[];
  };
}>({} as any);

// è‡ªå®šä¹‰Hook
const useExecutionContext = () => {
  const context = useContext(ExecutionContext);
  if (!context) {
    throw new Error('useExecutionContext must be used within ExecutionProvider');
  }
  return context;
};
```

### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### 1. ç»„ä»¶ä¼˜åŒ–
```typescript
// ä½¿ç”¨React.memoé˜²æ­¢ä¸å¿…è¦çš„é‡æ¸²æŸ“
const SmartVariableInput = React.memo<SmartVariableInputProps>(
  ({ value, onChange, availableVariables, ...props }) => {
    // ç»„ä»¶å®ç°...
  },
  (prevProps, nextProps) => {
    // è‡ªå®šä¹‰æ¯”è¾ƒé€»è¾‘ï¼Œæ·±åº¦æ¯”è¾ƒavailableVariables
    return isEqual(prevProps.availableVariables, nextProps.availableVariables) &&
           prevProps.value === nextProps.value;
  }
);

// ä½¿ç”¨useMemoç¼“å­˜æ˜‚è´µè®¡ç®—
const useVariableSuggestions = (availableVariables: Variable[], searchText: string) => {
  return useMemo(() => {
    if (!searchText) return availableVariables;
    
    return availableVariables
      .filter(variable => 
        variable.name.toLowerCase().includes(searchText.toLowerCase())
      )
      .sort((a, b) => {
        // æŒ‰åŒ¹é…åº¦å’Œä½¿ç”¨é¢‘ç‡æ’åº
        const aScore = getMatchScore(a.name, searchText);
        const bScore = getMatchScore(b.name, searchText);
        return bScore - aScore;
      });
  }, [availableVariables, searchText]);
};
```

#### 2. ç½‘ç»œä¼˜åŒ–
```typescript
// ä½¿ç”¨SWRè¿›è¡Œæ•°æ®ç¼“å­˜å’ŒåŒæ­¥
const useVariables = (executionId: string) => {
  return useSWR(
    executionId ? `/api/v1/executions/${executionId}/variables` : null,
    fetcher,
    {
      refreshInterval: 5000, // 5ç§’è‡ªåŠ¨åˆ·æ–°
      revalidateOnFocus: true,
      dedupingInterval: 2000, // 2ç§’å†…é‡å¤è¯·æ±‚å»é‡
    }
  );
};

// é˜²æŠ–å¤„ç†ç”¨æˆ·è¾“å…¥
const useDebouncedValidation = (text: string, delay: number = 300) => {
  const [validationResult, setValidationResult] = useState<ValidationResult | null>(null);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      if (text) {
        validateVariableReferences(text).then(setValidationResult);
      }
    }, delay);
    
    return () => clearTimeout(timer);
  }, [text, delay]);
  
  return validationResult;
};
```

---

## ğŸ—„ï¸ åç«¯æŠ€æœ¯è§„æ ¼

### Flaskåº”ç”¨æ¶æ„

#### 1. æœåŠ¡å±‚è®¾è®¡
```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
from dataclasses import dataclass

@dataclass
class Variable:
    name: str
    value: Any
    data_type: str
    source_step: int
    api_method: str
    created_at: datetime

class VariableService(ABC):
    @abstractmethod
    def store_variable(self, execution_id: str, variable: Variable) -> bool:
        pass
    
    @abstractmethod
    def get_variable(self, execution_id: str, variable_name: str) -> Optional[Variable]:
        pass
    
    @abstractmethod
    def get_all_variables(self, execution_id: str) -> List[Variable]:
        pass

class PostgreSQLVariableService(VariableService):
    def __init__(self, db_session):
        self.db = db_session
    
    def store_variable(self, execution_id: str, variable: Variable) -> bool:
        try:
            context = ExecutionContext(
                execution_id=execution_id,
                variable_name=variable.name,
                variable_value=json.dumps(variable.value),
                variable_type=variable.data_type,
                source_step_index=variable.source_step,
                api_method=variable.api_method
            )
            self.db.add(context)
            self.db.commit()
            return True
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to store variable: {e}")
            return False

class VariableResolverService:
    def __init__(self, variable_service: VariableService):
        self.variable_service = variable_service
        self.variable_pattern = re.compile(r'\$\{([^}]+)\}')
    
    def resolve_parameters(self, execution_id: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """è§£æå‚æ•°ä¸­çš„å˜é‡å¼•ç”¨"""
        resolved_params = {}
        
        for key, value in params.items():
            if isinstance(value, str):
                resolved_params[key] = self._resolve_string_value(execution_id, value)
            else:
                resolved_params[key] = value
        
        return resolved_params
    
    def _resolve_string_value(self, execution_id: str, text: str) -> str:
        """è§£æå­—ç¬¦ä¸²ä¸­çš„å˜é‡å¼•ç”¨"""
        def replace_variable(match):
            variable_path = match.group(1)
            return self._get_variable_value(execution_id, variable_path)
        
        return self.variable_pattern.sub(replace_variable, text)
    
    def _get_variable_value(self, execution_id: str, variable_path: str) -> str:
        """æ ¹æ®å˜é‡è·¯å¾„è·å–å€¼"""
        # è§£æå˜é‡è·¯å¾„: variable_name.property[0].field
        path_parts = self._parse_variable_path(variable_path)
        variable_name = path_parts[0]
        
        variable = self.variable_service.get_variable(execution_id, variable_name)
        if not variable:
            raise VariableNotFoundError(variable_name)
        
        # éå†å±æ€§è·¯å¾„
        current_value = variable.value
        for part in path_parts[1:]:
            current_value = self._access_property(current_value, part, variable_name)
        
        return str(current_value)
```

#### 2. APIè·¯ç”±è®¾è®¡
```python
from flask import Blueprint, request, jsonify
from flask_cors import cross_origin

api_v1 = Blueprint('api_v1', __name__, url_prefix='/api/v1')

@api_v1.route('/executions/<execution_id>/steps', methods=['POST'])
@cross_origin()
def execute_step(execution_id):
    """æ‰§è¡Œæµ‹è¯•æ­¥éª¤å¹¶æ•è·è¿”å›å€¼"""
    try:
        data = request.get_json()
        action = data.get('action')
        params = data.get('params', {})
        output_variable = data.get('output_variable')
        step_index = data.get('step_index', 0)
        
        # è§£æå‚æ•°ä¸­çš„å˜é‡å¼•ç”¨
        resolver = VariableResolverService(variable_service)
        resolved_params = resolver.resolve_parameters(execution_id, params)
        
        # è°ƒç”¨MidSceneJS API
        midscene_client = MidSceneClient()
        result = midscene_client.execute_action(action, resolved_params)
        
        # å¦‚æœæŒ‡å®šäº†è¾“å‡ºå˜é‡ï¼Œå­˜å‚¨ç»“æœ
        if output_variable and result is not None:
            variable = Variable(
                name=output_variable,
                value=result,
                data_type=type(result).__name__.lower(),
                source_step=step_index,
                api_method=action,
                created_at=datetime.utcnow()
            )
            variable_service.store_variable(execution_id, variable)
        
        return jsonify({
            'success': True,
            'data': {
                'result': result,
                'variable': output_variable,
                'resolved_params': resolved_params
            }
        })
        
    except VariableNotFoundError as e:
        return jsonify({
            'success': False,
            'error': {
                'type': 'VARIABLE_NOT_FOUND',
                'message': str(e),
                'variable_name': e.variable_name
            }
        }), 400
        
    except Exception as e:
        logger.error(f"Step execution failed: {e}")
        return jsonify({
            'success': False,
            'error': {
                'type': 'EXECUTION_ERROR',
                'message': str(e)
            }
        }), 500

@api_v1.route('/executions/<execution_id>/variables', methods=['GET'])
@cross_origin()
def get_variables(execution_id):
    """è·å–æ‰§è¡Œä¸Šä¸‹æ–‡ä¸­çš„æ‰€æœ‰å˜é‡"""
    try:
        variables = variable_service.get_all_variables(execution_id)
        return jsonify({
            'success': True,
            'data': [var.__dict__ for var in variables]
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500
```

### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### 1. æ•°æ®åº“ä¼˜åŒ–
```sql
-- åˆ›å»ºå¤åˆç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
CREATE INDEX idx_execution_variables ON execution_contexts(execution_id, variable_name);
CREATE INDEX idx_step_output ON step_executions(execution_id, output_variable);

-- åˆ†åŒºè¡¨ç­–ç•¥ï¼ˆæŒ‰æ—¥æœŸåˆ†åŒºï¼‰
CREATE TABLE execution_contexts_2025_01 PARTITION OF execution_contexts
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- æŸ¥è¯¢ä¼˜åŒ–
EXPLAIN ANALYZE 
SELECT variable_name, variable_value, variable_type 
FROM execution_contexts 
WHERE execution_id = 'exec_123' 
ORDER BY source_step_index;
```

#### 2. ç¼“å­˜ç­–ç•¥
```python
import redis
from functools import wraps

class VariableCacheService:
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.default_ttl = 3600  # 1å°æ—¶
    
    def get_cached_variables(self, execution_id: str) -> Optional[List[Variable]]:
        """ä»ç¼“å­˜è·å–å˜é‡åˆ—è¡¨"""
        cache_key = f"variables:{execution_id}"
        cached_data = self.redis.get(cache_key)
        
        if cached_data:
            variables_data = json.loads(cached_data)
            return [Variable(**data) for data in variables_data]
        
        return None
    
    def cache_variables(self, execution_id: str, variables: List[Variable], ttl: int = None):
        """ç¼“å­˜å˜é‡åˆ—è¡¨"""
        cache_key = f"variables:{execution_id}"
        variables_data = [var.__dict__ for var in variables]
        
        self.redis.setex(
            cache_key, 
            ttl or self.default_ttl,
            json.dumps(variables_data, default=str)
        )

def cache_result(cache_key_func, ttl=3600):
    """ç¼“å­˜è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            cache_key = cache_key_func(*args, **kwargs)
            
            # å°è¯•ä»ç¼“å­˜è·å–
            cached_result = cache_service.get(cache_key)
            if cached_result:
                return json.loads(cached_result)
            
            # æ‰§è¡Œå‡½æ•°å¹¶ç¼“å­˜ç»“æœ
            result = func(*args, **kwargs)
            cache_service.setex(cache_key, ttl, json.dumps(result, default=str))
            
            return result
        return wrapper
    return decorator
```

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•è§„èŒƒ

#### 1. å˜é‡è§£æå™¨æµ‹è¯•
```python
import pytest
from unittest.mock import Mock, patch

class TestVariableResolver:
    def setup_method(self):
        self.mock_variable_service = Mock()
        self.resolver = VariableResolverService(self.mock_variable_service)
    
    def test_simple_variable_resolution(self):
        """æµ‹è¯•ç®€å•å˜é‡è§£æ"""
        # å‡†å¤‡æµ‹è¯•æ•°æ®
        self.mock_variable_service.get_variable.return_value = Variable(
            name='user_name',
            value='John',
            data_type='string',
            source_step=1,
            api_method='aiString',
            created_at=datetime.utcnow()
        )
        
        # æ‰§è¡Œæµ‹è¯•
        result = self.resolver._resolve_string_value('exec_123', 'Hello ${user_name}!')
        
        # éªŒè¯ç»“æœ
        assert result == 'Hello John!'
        self.mock_variable_service.get_variable.assert_called_once_with('exec_123', 'user_name')
    
    def test_nested_property_access(self):
        """æµ‹è¯•åµŒå¥—å±æ€§è®¿é—®"""
        # å‡†å¤‡æµ‹è¯•æ•°æ®
        self.mock_variable_service.get_variable.return_value = Variable(
            name='user_data',
            value={'profile': {'name': 'John', 'age': 30}},
            data_type='object',
            source_step=1,
            api_method='aiQuery',
            created_at=datetime.utcnow()
        )
        
        # æ‰§è¡Œæµ‹è¯•
        result = self.resolver._resolve_string_value('exec_123', 'User: ${user_data.profile.name}')
        
        # éªŒè¯ç»“æœ
        assert result == 'User: John'
    
    def test_variable_not_found_error(self):
        """æµ‹è¯•å˜é‡æœªæ‰¾åˆ°é”™è¯¯"""
        self.mock_variable_service.get_variable.return_value = None
        
        with pytest.raises(VariableNotFoundError) as exc_info:
            self.resolver._resolve_string_value('exec_123', '${nonexistent_var}')
        
        assert exc_info.value.variable_name == 'nonexistent_var'
```

#### 2. APIç«¯ç‚¹æµ‹è¯•
```python
class TestExecutionAPI:
    def setup_method(self):
        self.app = create_app({'TESTING': True})
        self.client = self.app.test_client()
    
    @patch('api_routes.MidSceneClient')
    @patch('api_routes.variable_service')
    def test_execute_step_with_output_variable(self, mock_variable_service, mock_midscene):
        """æµ‹è¯•å¸¦è¾“å‡ºå˜é‡çš„æ­¥éª¤æ‰§è¡Œ"""
        # å‡†å¤‡æµ‹è¯•æ•°æ®
        mock_midscene.return_value.execute_action.return_value = {
            'name': 'iPhone',
            'price': 999
        }
        mock_variable_service.store_variable.return_value = True
        
        # å‘é€è¯·æ±‚
        response = self.client.post('/api/v1/executions/test_exec/steps', 
            json={
                'action': 'aiQuery',
                'params': {
                    'query': 'æå–å•†å“ä¿¡æ¯',
                    'dataDemand': '{name: string, price: number}'
                },
                'output_variable': 'product_info',
                'step_index': 1
            })
        
        # éªŒè¯å“åº”
        assert response.status_code == 200
        data = response.get_json()
        assert data['success'] is True
        assert data['data']['variable'] == 'product_info'
        assert data['data']['result']['name'] == 'iPhone'
        
        # éªŒè¯æœåŠ¡è°ƒç”¨
        mock_variable_service.store_variable.assert_called_once()
```

### é›†æˆæµ‹è¯•è§„èŒƒ

#### 1. ç«¯åˆ°ç«¯æ•°æ®æµæµ‹è¯•
```python
class TestDataFlowIntegration:
    def setup_method(self):
        self.app = create_test_app()
        self.client = self.app.test_client()
        self.test_execution_id = 'integration_test_' + str(uuid.uuid4())
    
    def test_complete_dataflow_workflow(self):
        """æµ‹è¯•å®Œæ•´çš„æ•°æ®æµå·¥ä½œæµ"""
        
        # ç¬¬ä¸€æ­¥ï¼šæ‰§è¡Œæ•°æ®æå–
        response1 = self.client.post(f'/api/v1/executions/{self.test_execution_id}/steps',
            json={
                'action': 'aiQuery',
                'params': {
                    'query': 'æå–å•†å“ä¿¡æ¯',
                    'dataDemand': '{name: string, price: number}'
                },
                'output_variable': 'product_info',
                'step_index': 1
            })
        
        assert response1.status_code == 200
        assert response1.get_json()['success'] is True
        
        # ç¬¬äºŒæ­¥ï¼šä½¿ç”¨æå–çš„æ•°æ®
        response2 = self.client.post(f'/api/v1/executions/{self.test_execution_id}/steps',
            json={
                'action': 'ai_input',
                'params': {
                    'text': 'å•†å“åç§°ï¼š${product_info.name}ï¼Œä»·æ ¼ï¼š${product_info.price}',
                    'locate': 'å•†å“ä¿¡æ¯è¾“å…¥æ¡†'
                },
                'step_index': 2
            })
        
        assert response2.status_code == 200
        response_data = response2.get_json()
        assert response_data['success'] is True
        
        # éªŒè¯å˜é‡è§£æç»“æœ
        resolved_text = response_data['data']['resolved_params']['text']
        assert 'iPhone' in resolved_text
        assert '999' in resolved_text
```

### æ€§èƒ½æµ‹è¯•è§„èŒƒ

#### 1. è´Ÿè½½æµ‹è¯•
```python
import asyncio
import aiohttp
import time

class PerformanceTestSuite:
    async def test_concurrent_variable_resolution(self):
        """æµ‹è¯•å¹¶å‘å˜é‡è§£ææ€§èƒ½"""
        
        async def single_request():
            async with aiohttp.ClientSession() as session:
                start_time = time.time()
                async with session.post('/api/v1/steps/validate', json={
                    'step': {
                        'action': 'ai_input',
                        'params': {
                            'text': 'Hello ${user_name} with ${product_info.price}'
                        }
                    },
                    'available_variables': ['user_name', 'product_info']
                }) as response:
                    result = await response.json()
                    end_time = time.time()
                    return end_time - start_time, result
        
        # å¹¶å‘æ‰§è¡Œ100ä¸ªè¯·æ±‚
        tasks = [single_request() for _ in range(100)]
        results = await asyncio.gather(*tasks)
        
        # åˆ†ææ€§èƒ½æŒ‡æ ‡
        response_times = [result[0] for result in results]
        avg_time = sum(response_times) / len(response_times)
        p95_time = sorted(response_times)[int(len(response_times) * 0.95)]
        
        # éªŒè¯æ€§èƒ½è¦æ±‚
        assert avg_time < 0.3  # å¹³å‡å“åº”æ—¶é—´ < 300ms
        assert p95_time < 0.5  # P95å“åº”æ—¶é—´ < 500ms
        
        # éªŒè¯æ‰€æœ‰è¯·æ±‚æˆåŠŸ
        success_count = sum(1 for _, result in results if result.get('success'))
        assert success_count == 100
```

---

## ğŸ“ˆ ç›‘æ§å’Œå¯è§‚æµ‹æ€§

### æ€§èƒ½ç›‘æ§æŒ‡æ ‡

#### 1. åº”ç”¨æ€§èƒ½æŒ‡æ ‡
```python
from prometheus_client import Counter, Histogram, Gauge, start_http_server

# å®šä¹‰ç›‘æ§æŒ‡æ ‡
VARIABLE_RESOLUTION_DURATION = Histogram(
    'variable_resolution_duration_seconds',
    'Time spent resolving variables',
    ['execution_id', 'variable_count']
)

VARIABLE_STORAGE_OPERATIONS = Counter(
    'variable_storage_operations_total',
    'Total variable storage operations', 
    ['operation', 'status']
)

ACTIVE_EXECUTIONS = Gauge(
    'active_executions_count',
    'Number of active test executions'
)

SMART_SUGGESTIONS_REQUESTS = Counter(
    'smart_suggestions_requests_total',
    'Total smart suggestion requests',
    ['request_type', 'status']
)

# ç›‘æ§è£…é¥°å™¨
def monitor_performance(metric_name: str):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()
            
            try:
                result = func(*args, **kwargs)
                status = 'success'
                return result
            except Exception as e:
                status = 'error'
                raise
            finally:
                duration = time.time() - start_time
                
                if metric_name == 'variable_resolution':
                    VARIABLE_RESOLUTION_DURATION.observe(duration)
                
                # è®°å½•æ“ä½œè®¡æ•°
                VARIABLE_STORAGE_OPERATIONS.labels(
                    operation=func.__name__,
                    status=status
                ).inc()
        
        return wrapper
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
@monitor_performance('variable_resolution')
def resolve_variables(execution_id: str, text: str) -> str:
    # å˜é‡è§£æé€»è¾‘
    pass
```

#### 2. ä¸šåŠ¡ç›‘æ§æŒ‡æ ‡
```python
# ç”¨æˆ·è¡Œä¸ºæŒ‡æ ‡
USER_ACTIONS = Counter(
    'user_actions_total',
    'Total user actions',
    ['action_type', 'user_type']
)

FEATURE_USAGE = Counter(
    'feature_usage_total', 
    'Feature usage statistics',
    ['feature', 'user_id']
)

ERROR_RATES = Counter(
    'error_rates_total',
    'Error rates by type',
    ['error_type', 'severity']
)

# ä¸šåŠ¡æŒ‡æ ‡æ”¶é›†
def track_user_action(action_type: str, user_type: str):
    USER_ACTIONS.labels(action_type=action_type, user_type=user_type).inc()

def track_feature_usage(feature: str, user_id: str):
    FEATURE_USAGE.labels(feature=feature, user_id=user_id).inc()
```

### æ—¥å¿—è®°å½•è§„èŒƒ

#### 1. ç»“æ„åŒ–æ—¥å¿—
```python
import structlog
import logging
from pythonjsonlogger import jsonlogger

# é…ç½®ç»“æ„åŒ–æ—¥å¿—
def configure_logging():
    # JSONæ ¼å¼æ—¥å¿—
    json_handler = logging.StreamHandler()
    formatter = jsonlogger.JsonFormatter(
        '%(asctime)s %(name)s %(levelname)s %(funcName)s %(lineno)d %(message)s'
    )
    json_handler.setFormatter(formatter)
    
    # åˆ†ç±»æ—¥å¿—è®°å½•å™¨
    loggers = {
        'dataflow': logging.getLogger('dataflow'),
        'variable_resolution': logging.getLogger('variable_resolution'),
        'api_performance': logging.getLogger('api_performance'),
        'user_behavior': logging.getLogger('user_behavior')
    }
    
    for logger in loggers.values():
        logger.addHandler(json_handler)
        logger.setLevel(logging.INFO)
    
    return loggers

# ä½¿ç”¨ç¤ºä¾‹
logger = configure_logging()['dataflow']

def store_variable(execution_id: str, variable: Variable):
    logger.info("Variable storage started", extra={
        'execution_id': execution_id,
        'variable_name': variable.name,
        'variable_type': variable.data_type,
        'data_size': len(str(variable.value))
    })
    
    try:
        # å­˜å‚¨é€»è¾‘
        result = perform_storage(variable)
        
        logger.info("Variable storage completed", extra={
            'execution_id': execution_id,
            'variable_name': variable.name,
            'storage_time_ms': result.duration,
            'status': 'success'
        })
        
    except Exception as e:
        logger.error("Variable storage failed", extra={
            'execution_id': execution_id,
            'variable_name': variable.name,
            'error': str(e),
            'error_type': type(e).__name__,
            'status': 'error'
        })
        raise
```

---

## ğŸ”’ å®‰å…¨è§„èŒƒ

### æ•°æ®å®‰å…¨

#### 1. å˜é‡æ•°æ®åŠ å¯†
```python
from cryptography.fernet import Fernet
import os
import base64

class VariableEncryption:
    def __init__(self):
        # ä»ç¯å¢ƒå˜é‡è·å–åŠ å¯†å¯†é’¥
        key = os.getenv('VARIABLE_ENCRYPTION_KEY')
        if not key:
            key = Fernet.generate_key()
            # åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œå¯†é’¥åº”è¯¥å­˜å‚¨åœ¨å®‰å…¨çš„å¯†é’¥ç®¡ç†æœåŠ¡ä¸­
        
        self.cipher_suite = Fernet(key)
    
    def encrypt_variable_data(self, data: Any) -> str:
        """åŠ å¯†å˜é‡æ•°æ®"""
        json_data = json.dumps(data, ensure_ascii=False)
        encrypted_data = self.cipher_suite.encrypt(json_data.encode('utf-8'))
        return base64.urlsafe_b64encode(encrypted_data).decode('ascii')
    
    def decrypt_variable_data(self, encrypted_data: str) -> Any:
        """è§£å¯†å˜é‡æ•°æ®"""
        encrypted_bytes = base64.urlsafe_b64decode(encrypted_data.encode('ascii'))
        decrypted_data = self.cipher_suite.decrypt(encrypted_bytes)
        return json.loads(decrypted_data.decode('utf-8'))
```

#### 2. è®¿é—®æ§åˆ¶
```python
from functools import wraps
from flask import request, jsonify
import jwt

def require_execution_access(f):
    """éªŒè¯ç”¨æˆ·å¯¹æ‰§è¡Œä¸Šä¸‹æ–‡çš„è®¿é—®æƒé™"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        execution_id = kwargs.get('execution_id')
        if not execution_id:
            return jsonify({'error': 'Execution ID required'}), 400
        
        # ä»è¯·æ±‚å¤´è·å–ç”¨æˆ·ä¿¡æ¯
        token = request.headers.get('Authorization', '').replace('Bearer ', '')
        if not token:
            return jsonify({'error': 'Authentication required'}), 401
        
        try:
            payload = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            user_id = payload['user_id']
            
            # éªŒè¯ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®è¯¥æ‰§è¡Œ
            if not has_execution_access(user_id, execution_id):
                return jsonify({'error': 'Access denied'}), 403
            
            # å°†ç”¨æˆ·ä¿¡æ¯æ·»åŠ åˆ°è¯·æ±‚ä¸Šä¸‹æ–‡
            request.current_user = payload
            
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
        
        return f(*args, **kwargs)
    
    return decorated_function

def has_execution_access(user_id: str, execution_id: str) -> bool:
    """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æ‰§è¡Œä¸Šä¸‹æ–‡"""
    # æŸ¥è¯¢æ‰§è¡Œè®°å½•çš„åˆ›å»ºè€…æˆ–å›¢é˜Ÿæˆå‘˜
    execution = ExecutionHistory.query.filter_by(execution_id=execution_id).first()
    if not execution:
        return False
    
    return (execution.executed_by == user_id or 
            is_team_member(user_id, execution.team_id))
```

### è¾“å…¥éªŒè¯å’Œé˜²æŠ¤

#### 1. å˜é‡å¼•ç”¨å®‰å…¨éªŒè¯
```python
import re
from typing import List

class VariableSecurityValidator:
    # å®‰å…¨çš„å˜é‡åæ¨¡å¼
    SAFE_VARIABLE_PATTERN = re.compile(r'^[a-zA-Z_][a-zA-Z0-9_]*$')
    # å®‰å…¨çš„å±æ€§è®¿é—®æ¨¡å¼
    SAFE_PROPERTY_PATTERN = re.compile(r'^[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)*(\[\d+\])*$')
    
    @classmethod
    def validate_variable_reference(cls, variable_path: str) -> bool:
        """éªŒè¯å˜é‡å¼•ç”¨è·¯å¾„çš„å®‰å…¨æ€§"""
        if not variable_path:
            return False
        
        # æ£€æŸ¥æ˜¯å¦åŒ…å«å±é™©å­—ç¬¦
        dangerous_patterns = [
            r'\.\./',  # è·¯å¾„éå†
            r'__\w+__',  # Pythonå†…ç½®å±æ€§
            r'eval|exec|import|open|file',  # å±é™©å‡½æ•°
            r'<script|javascript:|data:',  # XSSæ¨¡å¼
        ]
        
        for pattern in dangerous_patterns:
            if re.search(pattern, variable_path, re.IGNORECASE):
                return False
        
        # éªŒè¯è·¯å¾„æ ¼å¼
        return bool(cls.SAFE_PROPERTY_PATTERN.match(variable_path))
    
    @classmethod
    def sanitize_variable_value(cls, value: Any) -> Any:
        """æ¸…ç†å˜é‡å€¼ï¼Œé˜²æ­¢XSSç­‰æ”»å‡»"""
        if isinstance(value, str):
            # HTMLè½¬ä¹‰
            import html
            return html.escape(value)
        elif isinstance(value, dict):
            return {k: cls.sanitize_variable_value(v) for k, v in value.items()}
        elif isinstance(value, list):
            return [cls.sanitize_variable_value(item) for item in value]
        else:
            return value
```

---

**æ–‡æ¡£çŠ¶æ€**: å¾…æŠ€æœ¯è¯„å®¡  
**è¯„å®¡äºº**: æŠ€æœ¯è´Ÿè´£äººã€æ¶æ„å¸ˆã€å®‰å…¨ä¸“å®¶  
**ä¸‹ä¸€æ­¥**: åŸºäºæ­¤æŠ€æœ¯è§„æ ¼è¿›è¡Œè¯¦ç»†è®¾è®¡å’Œå¼€å‘è®¡åˆ’åˆ¶å®š  

*æœ¬æ–‡æ¡£ä¸ºæŠ€æœ¯å›¢é˜Ÿæä¾›è¯¦ç»†çš„å®ç°æŒ‡å¯¼ï¼Œæ¶µç›–æ¶æ„è®¾è®¡ã€APIè§„èŒƒã€æ€§èƒ½è¦æ±‚ã€æµ‹è¯•ç­–ç•¥å’Œå®‰å…¨è§„èŒƒ*