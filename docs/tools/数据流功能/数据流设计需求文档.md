# Intent Test Framework 数据流设计需求文档

**文档版本**: 1.0  
**创建日期**: 2025-01-30  
**创建人**: Mary (Business Analyst)  
**项目**: Intent Test Framework  

---

## 📋 项目概述

### 背景
当前Intent Test Framework中的测试步骤执行是独立的，但在实际测试场景中，某些操作步骤（如数据提取）会产生输出，这些输出应该能够作为后续步骤的输入，形成数据流链路。

### 目标
设计并实现一套数据流管理系统，使测试步骤能够输出数据并供后续步骤引用，同时提供类似代码编辑器的智能提示功能，并优化步骤参数的格式和验证机制。

---

## 🎯 需求分析

### 核心需求

#### 1. 现有API返回值捕获
- **需求描述**: 现有的Midscene API方法（如aiQuery、aiString等）的返回值能够被捕获并存储为变量
- **用户故事**: 作为测试用例编写者，我希望现有的数据提取方法（aiQuery、aiString、aiNumber等）的返回值能够自动保存，并在后续步骤中使用这些数据
- **验收标准**: 
  - 支持所有有返回值的Midscene API方法的输出捕获
  - 返回值数据能够存储并关联到具体的执行步骤  
  - 支持复杂对象、数组和基础数据类型

#### 2. 变量引用系统
- **需求描述**: 后续步骤能够通过变量语法引用前面步骤的输出
- **用户故事**: 作为测试用例编写者，我希望使用简单的语法（如`${product_info.price}`）来引用之前提取的数据
- **验收标准**:
  - 支持`${variable_name}`和`${variable_name.property}`语法
  - 支持嵌套对象属性访问
  - 运行时变量解析和替换
  - 变量作用域在测试用例执行期间有效

#### 3. 智能提示系统
- **需求描述**: 参数输入时提供类似IDE的智能代码完成功能
- **用户故事**: 作为测试用例编写者，我希望在输入变量引用时能够获得自动完成提示，避免拼写错误
- **验收标准**:
  - 输入`${`时自动触发变量提示下拉菜单
  - 显示可用变量列表，包含变量名、类型、来源步骤信息
  - 支持模糊搜索和实时过滤
  - 支持键盘快捷键操作（上下选择、回车确认、ESC取消）

#### 4. 参数格式优化
- **需求描述**: 简化步骤参数的配置方式，提供表单化的参数编辑体验
- **用户故事**: 作为测试用例编写者，我希望通过友好的表单界面配置步骤参数，而不是手动编写复杂的JSON
- **验收标准**:
  - 每种Action类型有标准化的参数定义
  - 自动生成对应的参数配置表单
  - 实时参数验证和错误提示
  - 支持必需参数和可选参数的区分显示

---

## 🏗️ 技术方案设计

### 整体架构

#### 混合方案（变量引用 + 智能提示）
采用以变量引用系统为基础，融合智能提示功能的混合方案，在实现复杂度、用户友好度和扩展性之间达到最佳平衡。

### 核心组件

#### 1. 数据模型扩展

**TestCase步骤结构扩展**:
```json
{
  "action": "aiQuery",
  "params": {
    "query": "提取商品价格和库存信息",
    "dataDemand": "{price: number, stock: number}"
  },
  "output_variable": "product_info",
  "description": "提取商品基本信息"
}
```

**StepExecution模型扩展**:
```sql
ALTER TABLE step_executions ADD COLUMN output_data TEXT;
ALTER TABLE step_executions ADD COLUMN output_variable VARCHAR(255);
```

#### 2. 变量解析引擎

**核心功能**:
- 解析`${variable.property}`语法
- 支持嵌套对象访问
- 运行时变量替换
- 类型自动转换

**实现示例**:
```python
class VariableResolver:
    def __init__(self, execution_context):
        self.context = execution_context
        self.variables = {}
    
    def resolve_variables(self, text: str) -> str:
        """解析并替换文本中的变量引用"""
        pattern = r'\$\{([^}]+)\}'
        return re.sub(pattern, self._replace_variable, text)
    
    def _replace_variable(self, match):
        var_path = match.group(1)
        return self._get_variable_value(var_path)
```

#### 3. MidSceneJS集成扩展

**新增数据提取Action**:
- `ai_extract_string`: 提取字符串数据
- `ai_extract_number`: 提取数字数据  
- `ai_extract_object`: 提取JSON对象数据
- `ai_extract_array`: 提取数组数据

**服务端API扩展**:
```javascript
app.post('/api/extract-data', async (req, res) => {
    const { query, schema, outputVariable } = req.body;
    
    try {
        const result = await page.aiQuery(query, schema);
        
        // 存储到执行上下文
        executionContext.setVariable(outputVariable, result);
        
        res.json({
            success: true,
            data: result,
            dataType: typeof result,
            variable: outputVariable
        });
    } catch (error) {
        res.json({
            success: false,
            error: error.message
        });
    }
});
```

#### 4. 智能提示UI组件

**SmartVariableInput组件**:
- 实时语法检测和解析
- 自动完成下拉菜单
- 变量信息展示（类型、来源、预览值）
- 键盘交互支持

**VariableSuggestionDropdown组件**:
- 变量列表展示
- 实时搜索过滤
- 类型图标和颜色编码
- 来源步骤信息

#### 5. 参数配置系统

**Action定义标准化**:
```javascript
const ACTION_DEFINITIONS = {
    'ai_extract_data': {
        displayName: '数据提取',
        icon: '📊',
        category: 'data',
        requiredParams: ['query', 'output_variable'],
        optionalParams: ['data_schema', 'timeout'],
        paramTemplates: {
            query: {
                type: 'string',
                placeholder: '描述要提取的数据',
                validation: 'required'
            },
            output_variable: {
                type: 'variable_name',
                placeholder: '变量名（如：product_info）',
                validation: 'required|variable_name'
            }
        }
    }
};
```

**智能表单生成器**:
- 根据Action定义自动生成表单
- 参数类型适配不同的输入组件
- 实时验证和错误提示
- 支持变量引用的参数使用SmartVariableInput

---

## 🎨 用户界面设计

### 测试用例编辑页面增强

#### 1. 步骤编辑器改进
- **输出配置区域**: 为支持数据输出的Action添加"输出配置"面板
- **参数智能输入**: 支持变量引用的参数字段使用智能输入组件
- **数据流可视化**: 显示步骤间的数据传递关系（可选的高级功能）

#### 2. 智能提示界面
- **自动完成下拉菜单**: 
  - 变量名、类型、来源步骤
  - 数据预览（执行过程中的实际值）
  - 使用频率排序
- **变量浏览器**: 侧边栏显示当前可用的所有变量
- **语法高亮**: 参数输入框中的变量引用语法高亮显示

#### 3. 参数配置表单
- **分类显示**: 必需参数、可选参数分区显示
- **上下文帮助**: 每个参数字段提供帮助提示和示例
- **预设模板**: 常用参数配置的快速选择模板

### 执行监控页面增强

#### 1. 数据流监控
- **变量状态面板**: 显示当前执行中的所有变量及其值
- **数据传递追踪**: 高亮显示数据在步骤间的传递路径
- **类型验证状态**: 显示变量类型转换和验证结果

#### 2. 调试信息
- **变量值历史**: 记录变量值的变化历史
- **解析日志**: 显示变量解析过程的详细日志
- **错误诊断**: 变量引用错误的详细诊断信息

---

## 📊 数据设计

### 数据库Schema变更

#### 1. TestCase表（现有表无需修改）
步骤的JSON结构支持新增字段，向后兼容。

#### 2. StepExecution表扩展
```sql
-- 添加输出数据相关字段
ALTER TABLE step_executions ADD COLUMN output_data TEXT COMMENT '步骤输出的数据（JSON格式）';
ALTER TABLE step_executions ADD COLUMN output_variable VARCHAR(255) COMMENT '输出变量名';
ALTER TABLE step_executions ADD COLUMN output_type VARCHAR(50) COMMENT '输出数据类型';
```

#### 3. 新增ExecutionContext表（可选）
```sql
CREATE TABLE execution_contexts (
    id INT PRIMARY KEY AUTO_INCREMENT,
    execution_id VARCHAR(50) NOT NULL,
    variable_name VARCHAR(255) NOT NULL,
    variable_value TEXT,
    variable_type VARCHAR(50),
    source_step_index INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (execution_id) REFERENCES execution_history(execution_id),
    UNIQUE KEY uk_execution_variable (execution_id, variable_name)
);
```

### 数据流设计

#### 1. 执行时数据流
```
步骤1: ai_extract_data (输出: product_info)
  ↓ 
执行上下文存储: {product_info: {price: 99.9, stock: 10}}
  ↓
步骤2: ai_input (输入: "价格：${product_info.price}")
  ↓
变量解析: "价格：99.9"
  ↓
实际执行
```

#### 2. 变量生命周期
- **创建**: 数据提取步骤执行成功后创建变量
- **存储**: 存储在执行上下文和数据库中
- **引用**: 后续步骤通过变量语法引用
- **销毁**: 测试用例执行完成后清理

---

## 🔧 技术实现要点

### 后端实现

#### 1. Python变量解析器
```python
class StepOutputManager:
    def __init__(self, execution_id):
        self.execution_id = execution_id
        self.variables = {}
    
    def store_output(self, variable_name: str, data: Any, data_type: str, step_index: int):
        """存储步骤输出数据"""
        self.variables[variable_name] = {
            'value': data,
            'type': data_type,
            'step_index': step_index,
            'timestamp': datetime.now()
        }
        
        # 同时存储到数据库
        self._persist_to_database(variable_name, data, data_type, step_index)
    
    def resolve_variables(self, text: str) -> str:
        """解析并替换文本中的变量引用"""
        pattern = r'\$\{([^}]+)\}'
        return re.sub(pattern, self._replace_variable, text)
```

#### 2. Flask API扩展
```python
@app.route('/api/v1/execution/<execution_id>/variables', methods=['GET'])
def get_execution_variables(execution_id):
    """获取执行上下文中的所有变量"""
    variables = StepOutputManager(execution_id).get_all_variables()
    return jsonify({
        'success': True,
        'variables': variables
    })

@app.route('/api/v1/testcase/<testcase_id>/available-variables', methods=['GET'])
def get_available_variables(testcase_id):
    """获取测试用例中可用的变量（基于步骤定义）"""
    testcase = TestCase.query.get(testcase_id)
    variables = []
    
    for i, step in enumerate(json.loads(testcase.steps)):
        if step.get('params', {}).get('output_variable'):
            variables.append({
                'name': step['params']['output_variable'],
                'type': step['params'].get('data_schema', 'unknown'),
                'source_step': i + 1,
                'description': step.get('description', '')
            })
    
    return jsonify({
        'success': True,
        'variables': variables
    })
```

### 前端实现

#### 1. React智能输入组件
```javascript
import React, { useState, useRef, useEffect } from 'react';

const SmartVariableInput = ({ value, onChange, availableVariables, placeholder }) => {
    const [showSuggestions, setShowSuggestions] = useState(false);
    const [suggestions, setSuggestions] = useState([]);
    const [selectedIndex, setSelectedIndex] = useState(0);
    const inputRef = useRef(null);

    const detectVariableReference = (text, cursorPos) => {
        const beforeCursor = text.substring(0, cursorPos);
        const match = beforeCursor.match(/\$\{([^}]*)$/);
        
        if (match) {
            return {
                prefix: match[1],
                startPos: match.index + 2,
                isPropertyAccess: match[1].includes('.')
            };
        }
        return null;
    };

    const handleInputChange = (e) => {
        const newValue = e.target.value;
        const cursorPos = e.target.selectionStart;
        
        onChange(newValue);
        
        const variableMatch = detectVariableReference(newValue, cursorPos);
        if (variableMatch) {
            showVariableSuggestions(variableMatch.prefix);
        } else {
            setShowSuggestions(false);
        }
    };

    const showVariableSuggestions = (prefix) => {
        const filtered = availableVariables.filter(variable => 
            variable.name.toLowerCase().includes(prefix.toLowerCase())
        );
        setSuggestions(filtered);
        setShowSuggestions(true);
        setSelectedIndex(0);
    };

    return (
        <div className="smart-variable-input">
            <textarea
                ref={inputRef}
                value={value}
                onChange={handleInputChange}
                placeholder={placeholder}
                className="form-input"
            />
            
            {showSuggestions && (
                <VariableSuggestionDropdown
                    suggestions={suggestions}
                    selectedIndex={selectedIndex}
                    onSelect={insertSuggestion}
                    onClose={() => setShowSuggestions(false)}
                />
            )}
        </div>
    );
};
```

#### 2. 参数表单生成器
```javascript
const StepParameterForm = ({ action, params, onChange, availableVariables }) => {
    const actionDef = ACTION_DEFINITIONS[action];
    
    if (!actionDef) {
        return <div>未知的操作类型: {action}</div>;
    }

    const renderParameterField = (paramName, paramConfig) => {
        const value = params[paramName] || paramConfig.default || '';
        
        switch (paramConfig.type) {
            case 'string':
                return paramConfig.supportVariables ? (
                    <SmartVariableInput 
                        value={value}
                        onChange={(val) => onChange(paramName, val)}
                        availableVariables={availableVariables}
                        placeholder={paramConfig.placeholder}
                    />
                ) : (
                    <input 
                        type="text"
                        value={value}
                        onChange={(e) => onChange(paramName, e.target.value)}
                        placeholder={paramConfig.placeholder}
                        className="form-input"
                    />
                );
                
            case 'variable_name':
                return (
                    <input 
                        type="text"
                        value={value}
                        onChange={(e) => onChange(paramName, e.target.value)}
                        placeholder={paramConfig.placeholder}
                        pattern={paramConfig.pattern}
                        className="form-input"
                    />
                );
                
            // ... 其他类型的处理
        }
    };

    return (
        <form className="step-parameter-form">
            <h3>{actionDef.displayName} {actionDef.icon}</h3>
            
            <div className="required-params">
                <h4>必需参数</h4>
                {actionDef.requiredParams.map(paramName => (
                    <div key={paramName} className="param-group">
                        <label>{paramName}</label>
                        {renderParameterField(paramName, actionDef.paramTemplates[paramName])}
                    </div>
                ))}
            </div>

            <div className="optional-params">
                <h4>可选参数</h4>
                {actionDef.optionalParams.map(paramName => (
                    <div key={paramName} className="param-group">
                        <label>{paramName}</label>
                        {renderParameterField(paramName, actionDef.paramTemplates[paramName])}
                    </div>
                ))}
            </div>
        </form>
    );
};
```

---

## 📅 实施计划

### Phase 1: 核心数据流功能（2-3周）

#### 开发任务
1. **数据模型扩展** (3天)
   - 数据库Schema迁移脚本
   - StepExecution模型扩展
   - ExecutionContext数据访问层

2. **变量解析引擎** (5天)
   - Python变量解析器实现
   - 变量语法解析和替换
   - 类型转换和验证

3. **MidSceneJS集成** (4天)
   - 新增数据提取Action
   - 服务端API扩展
   - 输出数据存储机制

4. **基础API开发** (3天)
   - 变量查询接口
   - 执行上下文管理接口
   - 数据持久化接口

#### 验收标准
- 支持基本的数据提取和变量引用功能
- 能够存储和查询执行过程中的变量数据
- 变量解析引擎能正确处理各种语法格式

### Phase 2: 智能提示系统（2-3周）

#### 开发任务
1. **智能输入组件** (5天)
   - SmartVariableInput React组件
   - 变量语法检测和解析
   - 自动完成触发逻辑

2. **提示界面组件** (4天)
   - VariableSuggestionDropdown组件
   - 变量信息展示和格式化
   - 键盘交互和选择逻辑

3. **前端集成** (3天)
   - 现有表单组件集成智能输入
   - 变量数据获取和缓存
   - 用户体验优化

4. **测试和调优** (3天)
   - 组件单元测试
   - 用户交互测试
   - 性能优化

#### 验收标准
- 智能提示功能能够正确触发和显示
- 用户能够通过键盘和鼠标操作选择变量
- 提示信息准确且有用（类型、来源、描述）

### Phase 3: 参数表单优化（2-3周）

#### 开发任务
1. **Action定义标准化** (4天)
   - 现有Action的参数定义重构
   - 参数模板和验证规则定义
   - 向后兼容性保证

2. **智能表单生成器** (5天)
   - StepParameterForm组件开发
   - 动态表单渲染逻辑
   - 参数类型适配和组件映射

3. **实时验证系统** (3天)
   - ParameterValidator实现
   - 实时验证和错误提示
   - 变量引用验证

4. **用户界面集成** (3天)
   - 测试用例编辑器集成新表单
   - 现有功能迁移和测试
   - UI/UX优化

#### 验收标准
- 用户能够通过表单界面轻松配置步骤参数
- 参数验证能够实时提供有用的错误信息
- 表单生成逻辑支持所有现有的Action类型

### Phase 4: 测试和部署（1周）

#### 开发任务
1. **集成测试** (2天)
   - 端到端测试用例编写
   - 数据流完整性测试
   - 性能测试

2. **文档和培训** (2天)
   - 用户使用文档更新
   - 开发者技术文档
   - 功能演示和培训材料

3. **部署准备** (3天)
   - 生产环境部署脚本
   - 数据迁移策略
   - 监控和日志配置

#### 验收标准
- 所有功能在生产环境中正常工作
- 用户能够顺利使用新功能
- 系统性能和稳定性符合预期

---

## ✅ 验收标准

### 功能验收标准

#### 1. 数据提取功能
- ✅ 支持ai_extract_string、ai_extract_number、ai_extract_object等Action
- ✅ 能够正确提取页面中的结构化数据
- ✅ 支持自定义数据Schema定义
- ✅ 提取结果能够存储到执行上下文中

#### 2. 变量引用功能
- ✅ 支持`${variable_name}`和`${variable_name.property}`语法
- ✅ 能够正确解析和替换变量引用
- ✅ 支持嵌套对象属性访问
- ✅ 类型转换和格式化正确

#### 3. 智能提示功能
- ✅ 输入`${`时自动触发提示
- ✅ 提示列表包含变量名、类型、来源步骤等信息
- ✅ 支持模糊搜索和实时过滤
- ✅ 键盘操作流畅（上下选择、回车确认、ESC取消）

#### 4. 参数表单功能
- ✅ 根据Action定义自动生成参数配置表单
- ✅ 支持不同参数类型的适配输入组件
- ✅ 实时参数验证和错误提示
- ✅ 必需参数和可选参数的区分显示

### 性能验收标准

#### 1. 响应时间
- 智能提示触发延迟 < 200ms
- 变量解析和替换 < 500ms
- 参数表单渲染 < 300ms

#### 2. 数据处理
- 支持单个测试用例中100+变量
- 支持复杂嵌套对象（5层深度）
- 变量数据存储和查询效率

#### 3. 用户体验
- 界面响应流畅，无明显卡顿
- 智能提示准确率 > 95%
- 参数验证错误提示准确且有用

### 兼容性验收标准

#### 1. 向后兼容
- 现有测试用例能够正常执行
- 现有API接口保持兼容
- 数据库迁移安全可靠

#### 2. 浏览器支持
- Chrome 90+
- Firefox 88+
- Safari 14+
- Edge 90+

---

## 🎯 成功度量指标

### 业务指标
- **用户采用率**: 新功能使用率 > 70%（发布后3个月）
- **错误减少**: 参数配置错误率降低 > 50%
- **效率提升**: 测试用例创建时间减少 > 30%
- **用户满意度**: 功能满意度评分 > 4.0/5.0

### 技术指标
- **系统稳定性**: 新功能相关bug < 5个/月
- **性能影响**: 系统整体响应时间增加 < 10%
- **代码质量**: 新增代码测试覆盖率 > 80%
- **维护成本**: 新功能维护工作量 < 20%总工作量

---

## 🔮 未来扩展计划

### 短期扩展（6个月内）
1. **数据转换功能**: 支持数据格式转换和计算
2. **条件执行**: 基于变量值的条件步骤执行
3. **循环执行**: 支持基于数据集的循环测试
4. **数据可视化**: 执行过程中的数据流可视化

### 长期扩展（1年内）
1. **AI智能推荐**: 基于上下文智能推荐变量使用
2. **模板市场**: 社区化的测试模板分享
3. **高级数据操作**: 支持复杂的数据查询和处理
4. **企业级功能**: 权限管理、审计日志等

---

## 📞 项目联系人

**产品负责人**: [待定]  
**技术负责人**: [待定]  
**业务分析师**: Mary  
**项目经理**: [待定]  

---

## 📎 附录

### A. 技术术语表
- **数据提取**: 从页面或DOM中获取结构化数据的过程
- **变量引用**: 通过特定语法引用之前步骤输出数据的机制
- **智能提示**: 类似IDE的自动代码完成功能
- **执行上下文**: 测试用例执行过程中的数据和状态管理容器

### B. 参考资料
- MidSceneJS官方文档: https://midscenejs.com/
- Intent Test Framework现有架构文档
- 用户研究和需求调研报告

### C. 风险评估
- **技术风险**: MidSceneJS API集成的复杂性
- **用户风险**: 学习成本和使用习惯改变
- **性能风险**: 大量变量处理的性能影响
- **兼容风险**: 现有功能的向后兼容性

---

**文档审批**:
- [ ] 业务需求审批
- [ ] 技术方案审批  
- [ ] 用户体验审批
- [ ] 项目计划审批

*此文档将随着项目进展持续更新和完善*