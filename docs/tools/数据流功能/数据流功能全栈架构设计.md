# Intent Test Framework 数据流功能全栈架构设计

**文档版本**: 1.0  
**创建日期**: 2025-01-30  
**架构师**: Winston  
**项目**: Intent Test Framework - 数据流功能增强  

---

## 🏗️ 架构概览

### 系统愿景
将Intent Test Framework从静态的步骤执行系统演进为智能的数据驱动测试平台，支持步骤间数据流传递、智能变量引用和用户友好的参数配置体验。

### 核心架构原则
1. **渐进式增强**: 在现有架构基础上平滑扩展，保持向后兼容
2. **性能优先**: 数据流处理不影响现有测试执行性能
3. **用户体验驱动**: 智能提示和表单优化显著提升使用体验
4. **可扩展设计**: 架构支持未来更复杂的数据操作需求
5. **安全可靠**: 变量解析和数据传递具备完整的验证和错误处理

---

## 🎯 架构目标与约束

### 业务目标
- **功能目标**: 实现步骤间数据传递和智能变量引用
- **体验目标**: 提供IDE级别的智能提示和表单化参数配置
- **性能目标**: 数据流处理延迟 < 500ms，智能提示响应 < 200ms
- **可用性目标**: 99.9%系统可用性，向后兼容100%现有测试用例

### 技术约束
- **现有技术栈**: Flask + React + PostgreSQL + MidSceneJS
- **部署环境**: Vercel + Supabase云服务 + 本地代理包
- **浏览器支持**: Chrome 90+, Firefox 88+, Safari 14+, Edge 90+
- **性能约束**: 单测试用例支持100+变量，5层嵌套对象访问

### 非功能性需求
- **可扩展性**: 支持10万+测试用例，1万+并发执行
- **可维护性**: 模块化设计，测试覆盖率 > 80%
- **安全性**: 变量数据加密存储，访问权限控制
- **可观测性**: 完整的日志记录和性能监控

---

## 🏛️ 整体系统架构

### 高层架构图
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Frontend      │    │   Backend       │    │  AI Engine     │
│                 │    │                 │    │                 │
│ • React UI      │────│ • Flask API     │────│ • MidSceneJS    │
│ • Smart Input   │    │ • Variable      │    │ • Playwright    │
│ • Form Builder  │    │   Resolver      │    │ • Data Extract  │
│                 │    │ • Validation    │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Data Layer    │    │  Execution      │    │  Infrastructure │
│                 │    │  Context        │    │                 │
│ • PostgreSQL    │    │                 │    │ • Vercel        │
│ • Variable      │────│ • Memory Store  │    │ • Supabase      │
│   Storage       │    │ • Session Mgmt  │    │ • Local Proxy   │
│ • Schema Mgmt   │    │ • Lifecycle     │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 数据流架构
```
用户输入 → 智能提示 → 参数验证 → 步骤执行 → 数据提取 → 变量存储 → 后续引用
    ↑         ↓         ↓         ↓         ↓         ↓         ↓
智能建议 ← UI组件 ← 表单生成 ← AI引擎 ← 解析器 ← 上下文 ← 变量解析
```

---

## 🎨 前端架构设计

### 组件架构层次
```
App Level
├── TestCaseEditor (Container)
│   ├── StepList (Presentation)
│   │   ├── StepItem (Smart Component)
│   │   │   ├── StepParameterForm (Smart Component)
│   │   │   │   ├── SmartVariableInput (Interactive)
│   │   │   │   │   └── VariableSuggestionDropdown
│   │   │   │   ├── ParameterField (Adaptive)
│   │   │   │   └── ValidationMessage (Pure)
│   │   │   └── OutputConfiguration (Feature Component)
│   │   └── AddStepButton (Action)
│   └── VariableBrowser (Context Display)
└── ExecutionMonitor (Container)
    ├── VariableViewer (Data Display)
    └── DataFlowVisualizer (Advanced Feature)
```

### 核心前端组件设计

#### 1. SmartVariableInput 组件
**职责**: 提供IDE级别的变量引用智能提示

**技术规格**:
```typescript
interface SmartVariableInputProps {
  value: string;
  onChange: (value: string) => void;
  availableVariables: Variable[];
  placeholder?: string;
  disabled?: boolean;
  validationErrors?: string[];
}

interface Variable {
  name: string;
  type: DataType;
  sourceStep: number;
  description: string;
  preview?: any;
  lastUpdated?: Date;
}

enum DataType {
  STRING = 'string',
  NUMBER = 'number', 
  BOOLEAN = 'boolean',
  OBJECT = 'object',
  ARRAY = 'array'
}
```

**核心功能实现**:
- 实时语法检测：正则表达式 `/\$\{([^}]*)/g` 检测变量引用
- 智能过滤：Fuse.js库实现模糊搜索
- 键盘导航：方向键选择，Enter确认，ESC取消
- 实时预览：显示变量当前值和类型信息

#### 2. StepParameterForm 组件
**职责**: 根据Action定义动态生成参数配置表单

**动态表单生成策略**:
```typescript
interface ActionDefinition {
  id: string;
  displayName: string;
  icon: string;
  category: ActionCategory;
  requiredParams: string[];
  optionalParams: string[];
  paramTemplates: Record<string, ParameterTemplate>;
}

interface ParameterTemplate {
  type: ParameterType;
  placeholder: string;
  validation: ValidationRule[];
  supportVariables: boolean;
  defaultValue?: any;
  options?: SelectOption[];
}

enum ParameterType {
  STRING = 'string',
  NUMBER = 'number',
  BOOLEAN = 'boolean',
  SELECT = 'select',
  TEXTAREA = 'textarea',
  VARIABLE_NAME = 'variable_name',
  JSON_SCHEMA = 'json_schema'
}
```

#### 3. VariableSuggestionDropdown 组件
**职责**: 显示变量提示列表，支持键盘和鼠标交互

**UI设计规范**:
- **变量分组**: 按数据类型和来源步骤分组显示
- **视觉层次**: 使用颜色编码区分不同数据类型
- **信息密度**: 显示变量名、类型、来源、预览值
- **交互反馈**: 悬停高亮、选中状态、加载状态

### 状态管理架构

#### Context API 状态分层
```typescript
// 全局应用状态
interface AppContextState {
  user: User;
  settings: AppSettings;
  theme: Theme;
}

// 测试用例编辑状态
interface TestCaseEditorState {
  testCase: TestCase;
  steps: Step[];
  availableVariables: Variable[];
  validationErrors: Record<string, string[]>;
  isDirty: boolean;
}

// 执行监控状态
interface ExecutionMonitorState {
  currentExecution: ExecutionHistory;
  executionContext: ExecutionContext;
  variableValues: Record<string, any>;
  stepStatus: StepExecutionStatus[];
}
```

#### 状态更新模式
- **Reducer模式**: 复杂状态变更使用useReducer管理
- **Optimistic UI**: 用户操作立即反映UI变化，后台同步
- **错误边界**: 组件级错误处理和用户友好的错误显示

### 性能优化策略

#### 渲染优化
- **React.memo**: 纯组件避免不必要重渲染
- **useMemo/useCallback**: 昂贵计算和函数缓存
- **虚拟化列表**: 大量步骤列表使用react-window
- **代码分割**: 动态导入非核心功能组件

#### 网络优化
- **SWR缓存**: 变量数据使用SWR实现缓存和重新验证
- **防抖处理**: 智能提示搜索使用300ms防抖
- **批量请求**: 多个变量查询合并为单个请求

---

## ⚙️ 后端架构设计

### 服务架构分层
```
Presentation Layer (API Routes)
├── /api/v1/testcases/          # 测试用例CRUD
├── /api/v1/variables/          # 变量管理API  
├── /api/v1/execution/          # 执行控制API
├── /api/v1/validation/         # 参数验证API
└── /api/v1/suggestions/        # 智能提示API

Business Logic Layer (Services)
├── TestCaseService             # 测试用例业务逻辑
├── VariableResolverService     # 变量解析服务
├── ExecutionContextService    # 执行上下文管理
├── ValidationService          # 参数验证服务
└── SuggestionService          # 智能提示服务

Data Access Layer (Repositories)
├── TestCaseRepository          # 测试用例数据访问
├── ExecutionHistoryRepository  # 执行历史数据访问
├── VariableRepository          # 变量数据访问
└── TemplateRepository          # 模板数据访问
```

### 核心服务设计

#### 1. VariableResolverService
**职责**: 解析和替换步骤参数中的变量引用

```python
class VariableResolverService:
    def __init__(self, execution_context: ExecutionContext):
        self.execution_context = execution_context
        self.variable_pattern = re.compile(r'\$\{([^}]+)\}')
    
    def resolve_step_parameters(self, step: Step) -> Step:
        """解析步骤参数中的所有变量引用"""
        resolved_params = {}
        
        for key, value in step.params.items():
            if isinstance(value, str):
                resolved_params[key] = self._resolve_string_value(value)
            else:
                resolved_params[key] = value
        
        return Step(
            action=step.action,
            params=resolved_params,
            description=step.description
        )
    
    def _resolve_string_value(self, text: str) -> str:
        """解析字符串中的变量引用"""
        def replace_variable(match):
            variable_path = match.group(1)
            return self._get_variable_value(variable_path)
        
        return self.variable_pattern.sub(replace_variable, text)
    
    def _get_variable_value(self, variable_path: str) -> str:
        """根据变量路径获取变量值"""
        path_parts = variable_path.split('.')
        variable_name = path_parts[0]
        
        variable_data = self.execution_context.get_variable(variable_name)
        if not variable_data:
            raise VariableNotFoundError(f"Variable '{variable_name}' not found")
        
        # 支持嵌套属性访问
        current_value = variable_data.value
        for property_name in path_parts[1:]:
            if isinstance(current_value, dict) and property_name in current_value:
                current_value = current_value[property_name]
            else:
                raise VariablePropertyError(
                    f"Property '{property_name}' not found in variable '{variable_name}'"
                )
        
        return str(current_value)
```

#### 2. ExecutionContextService
**职责**: 管理测试执行过程中的变量上下文

```python
class ExecutionContextService:
    def __init__(self, execution_id: str):
        self.execution_id = execution_id
        self.variables: Dict[str, VariableData] = {}
        self.redis_client = get_redis_client()  # 可选的Redis缓存
    
    def store_variable(self, 
                      variable_name: str, 
                      value: Any, 
                      data_type: DataType,
                      source_step: int) -> None:
        """存储步骤输出变量"""
        variable_data = VariableData(
            name=variable_name,
            value=value,
            data_type=data_type,
            source_step=source_step,
            created_at=datetime.utcnow()
        )
        
        # 内存存储
        self.variables[variable_name] = variable_data
        
        # 数据库持久化
        self._persist_variable(variable_data)
        
        # 可选的Redis缓存
        if self.redis_client:
            self._cache_variable(variable_data)
    
    def get_variable(self, variable_name: str) -> Optional[VariableData]:
        """获取变量数据"""
        # 优先从内存获取
        if variable_name in self.variables:
            return self.variables[variable_name]
        
        # 从缓存获取
        if self.redis_client:
            cached_data = self._get_cached_variable(variable_name)
            if cached_data:
                return cached_data
        
        # 从数据库获取
        return self._load_variable_from_db(variable_name)
    
    def get_all_variables(self) -> List[VariableData]:
        """获取所有可用变量"""
        return list(self.variables.values())
    
    def validate_variable_references(self, text: str) -> List[ValidationError]:
        """验证文本中的变量引用是否有效"""
        errors = []
        variable_pattern = re.compile(r'\$\{([^}]+)\}')
        
        for match in variable_pattern.finditer(text):
            variable_path = match.group(1)
            try:
                self._validate_variable_path(variable_path)
            except VariableError as e:
                errors.append(ValidationError(
                    message=str(e),
                    position=match.span(),
                    variable_path=variable_path
                ))
        
        return errors
```

#### 3. ValidationService
**职责**: 参数验证和错误处理

```python
class ValidationService:
    def __init__(self):
        self.action_definitions = load_action_definitions()
    
    def validate_step(self, step: Step, available_variables: List[str]) -> ValidationResult:
        """验证步骤配置"""
        errors = []
        warnings = []
        
        # 验证Action类型
        if step.action not in self.action_definitions:
            errors.append(f"Unknown action type: {step.action}")
            return ValidationResult(errors=errors, warnings=warnings)
        
        action_def = self.action_definitions[step.action]
        
        # 验证必需参数
        for required_param in action_def.required_params:
            if required_param not in step.params:
                errors.append(f"Missing required parameter: {required_param}")
        
        # 验证参数类型和格式
        for param_name, param_value in step.params.items():
            param_template = action_def.param_templates.get(param_name)
            if param_template:
                param_errors = self._validate_parameter(
                    param_name, param_value, param_template, available_variables
                )
                errors.extend(param_errors)
        
        return ValidationResult(errors=errors, warnings=warnings)
    
    def _validate_parameter(self, 
                           param_name: str,
                           param_value: Any,
                           param_template: ParameterTemplate,
                           available_variables: List[str]) -> List[str]:
        """验证单个参数"""
        errors = []
        
        # 类型验证
        if param_template.type == ParameterType.STRING:
            if not isinstance(param_value, str):
                errors.append(f"Parameter '{param_name}' must be a string")
        
        # 变量引用验证
        if param_template.support_variables and isinstance(param_value, str):
            variable_errors = self._validate_variable_references(
                param_value, available_variables
            )
            errors.extend(variable_errors)
        
        # 自定义验证规则
        for validation_rule in param_template.validation_rules:
            rule_errors = self._apply_validation_rule(param_value, validation_rule)
            errors.extend(rule_errors)
        
        return errors
```

### API设计规范

#### RESTful API结构
```python
# 变量管理API
GET    /api/v1/executions/{execution_id}/variables
POST   /api/v1/executions/{execution_id}/variables
GET    /api/v1/executions/{execution_id}/variables/{variable_name}
PUT    /api/v1/executions/{execution_id}/variables/{variable_name}
DELETE /api/v1/executions/{execution_id}/variables/{variable_name}

# 智能提示API
GET    /api/v1/testcases/{testcase_id}/variable-suggestions
POST   /api/v1/variables/search

# 参数验证API
POST   /api/v1/steps/validate
POST   /api/v1/testcases/{testcase_id}/validate

# 执行控制API
POST   /api/v1/testcases/{testcase_id}/execute
GET    /api/v1/executions/{execution_id}/status
POST   /api/v1/executions/{execution_id}/stop
```

#### API响应标准格式
```json
{
  "success": true,
  "data": {
    // 具体数据内容
  },
  "meta": {
    "timestamp": "2025-01-30T10:00:00Z",
    "request_id": "req_123456",
    "execution_time": "150ms"
  },
  "errors": [],
  "warnings": []
}
```

---

## 🤖 AI引擎架构增强

### MidSceneJS集成架构
```
MidSceneJS Server (Node.js)
├── Express HTTP API
│   ├── /api/extract-data          # 数据提取接口
│   ├── /api/extract-string        # 字符串提取
│   ├── /api/extract-number        # 数字提取
│   ├── /api/extract-object        # 对象提取
│   └── /api/extract-array         # 数组提取
├── Playwright Browser Manager
│   ├── Browser Pool Management    # 浏览器池管理
│   ├── Page Context Isolation     # 页面上下文隔离
│   └── Resource Optimization      # 资源优化
└── AI Model Integration
    ├── OpenAI/Qwen-VL Integration # AI模型集成
    ├── Token Usage Optimization   # Token使用优化
    └── Response Caching          # 响应缓存
```

### 现有API返回值捕获设计

#### 返回值捕获接口增强
```javascript
// 增强现有的Midscene API执行，支持返回值捕获
app.post('/api/execute-step', async (req, res) => {
    const { 
        action,          // 现有的Midscene API方法名 (aiQuery, aiString等)
        params,          // 原有的API参数
        outputVariable,  // 可选：输出变量名
        executionId      // 执行上下文ID
    } = req.body;
    
    try {
        // 获取当前页面实例
        const page = await getCurrentPage(req.headers['execution-id']);
        
        // 动态调用对应的Midscene API方法
        let result;
        switch(action) {
            case 'aiQuery':
                result = await page.aiQuery(params.query, params.dataDemand, params.options);
                break;
            case 'aiString':
                result = await page.aiString(params.query, params.options);
                break;
            case 'aiNumber':
                result = await page.aiNumber(params.query, params.options);
                break;
            case 'aiBoolean':
                result = await page.aiBoolean(params.query, params.options);
                break;
            case 'aiAsk':
                result = await page.aiAsk(params.question, params.options);
                break;
            case 'aiLocate':
                result = await page.aiLocate(params.prompt, params.options);
                break;
            case 'evaluateJavaScript':
                result = await page.evaluateJavaScript(params.script);
                break;
            default:
                // 对于没有返回值的方法，正常执行但不捕获返回值
                result = await page[action](params);
        }
        
        // 如果指定了输出变量名，则存储返回值
        if (outputVariable && result !== undefined) {
            await storeVariableData({
                executionId: executionId,
                variableName: outputVariable,
                value: result,
                dataType: typeof result,
                apiMethod: action,
                apiParams: params,
                timestamp: new Date()
            });
        }
        
        res.json({
            success: true,
            data: {
                result: result,
                variable: outputVariable,
                dataType: typeof result,
                executionTime: Date.now() - startTime
            }
        });
        
    } catch (error) {
        logger.error('API execution failed', { 
            error: error.message,
            action,
            params,
            executionId: executionId
        });
        
        res.status(500).json({
            success: false,
            error: {
                message: error.message,
                type: 'EXTRACTION_ERROR',
                query: query,
                suggestions: generateErrorSuggestions(error)
            }
        });
    }
});
```

#### 专用数据提取接口
```javascript
// 字符串提取
app.post('/api/extract-string', async (req, res) => {
    const { query, outputVariable } = req.body;
    const result = await page.aiString(query);
    // ... 处理逻辑
});

// 数字提取  
app.post('/api/extract-number', async (req, res) => {
    const { query, outputVariable } = req.body;
    const result = await page.aiNumber(query);
    // ... 处理逻辑
});

// 布尔值提取
app.post('/api/extract-boolean', async (req, res) => {
    const { query, outputVariable } = req.body;
    const result = await page.aiBoolean(query);
    // ... 处理逻辑
});
```

### AI性能优化策略

#### 1. 请求缓存机制
```javascript
class AIRequestCache {
    constructor() {
        this.cache = new Map();
        this.ttl = 5 * 60 * 1000; // 5分钟TTL
    }
    
    generateCacheKey(query, schema, pageHash) {
        return crypto.createHash('md5')
            .update(`${query}:${schema}:${pageHash}`)
            .digest('hex');
    }
    
    async get(cacheKey) {
        const cached = this.cache.get(cacheKey);
        if (cached && Date.now() - cached.timestamp < this.ttl) {
            return cached.data;
        }
        return null;
    }
    
    set(cacheKey, data) {
        this.cache.set(cacheKey, {
            data: data,
            timestamp: Date.now()
        });
    }
}
```

#### 2. 浏览器资源池管理
```javascript
class BrowserPoolManager {
    constructor() {
        this.browserPool = [];
        this.maxPoolSize = 5;
        this.currentPool = 0;
    }
    
    async getBrowser() {
        if (this.currentPool < this.maxPoolSize) {
            const browser = await chromium.launch({
                headless: true,
                args: [
                    '--no-sandbox',
                    '--disable-dev-shm-usage',
                    '--disable-background-timer-throttling',
                    '--disable-backgrounding-occluded-windows',
                    '--disable-renderer-backgrounding'
                ]
            });
            this.browserPool.push(browser);
            this.currentPool++;
            return browser;
        }
        
        // 复用现有浏览器实例
        return this.browserPool[Math.floor(Math.random() * this.browserPool.length)];
    }
    
    async cleanup() {
        for (const browser of this.browserPool) {
            await browser.close();
        }
        this.browserPool = [];
        this.currentPool = 0;
    }
}
```

---

## 🗄️ 数据架构设计

### 数据模型扩展

#### 核心表结构变更
```sql
-- 1. 扩展StepExecution表支持输出数据
ALTER TABLE step_executions 
ADD COLUMN output_data TEXT COMMENT '步骤输出数据(JSON格式)',
ADD COLUMN output_variable VARCHAR(255) COMMENT '输出变量名',
ADD COLUMN output_type VARCHAR(50) COMMENT '输出数据类型',
ADD COLUMN extraction_query TEXT COMMENT '数据提取查询',
ADD COLUMN extraction_schema TEXT COMMENT '数据提取Schema',
ADD INDEX idx_output_variable (output_variable),
ADD INDEX idx_execution_variable (execution_id, output_variable);

-- 2. 新增ExecutionContext表管理变量上下文
CREATE TABLE execution_contexts (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    execution_id VARCHAR(50) NOT NULL COMMENT '执行ID',
    variable_name VARCHAR(255) NOT NULL COMMENT '变量名',
    variable_value TEXT NOT NULL COMMENT '变量值(JSON格式)',
    variable_type ENUM('string', 'number', 'boolean', 'object', 'array') NOT NULL,
    source_step_index INT NOT NULL COMMENT '来源步骤索引',
    extraction_query TEXT COMMENT '数据提取查询',
    extraction_schema TEXT COMMENT '数据提取Schema',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (execution_id) REFERENCES execution_history(execution_id) ON DELETE CASCADE,
    UNIQUE KEY uk_execution_variable (execution_id, variable_name),
    INDEX idx_execution_id (execution_id),
    INDEX idx_variable_name (variable_name),
    INDEX idx_variable_type (variable_type),
    INDEX idx_source_step (source_step_index)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='执行上下文变量表';

-- 3. 新增ActionDefinitions表管理Action元数据  
CREATE TABLE action_definitions (
    id VARCHAR(100) PRIMARY KEY COMMENT 'Action ID',
    display_name VARCHAR(255) NOT NULL COMMENT '显示名称',
    icon VARCHAR(50) COMMENT '图标',
    category ENUM('navigation', 'interaction', 'assertion', 'data', 'control') NOT NULL,
    description TEXT COMMENT '描述',
    required_params JSON NOT NULL COMMENT '必需参数列表',
    optional_params JSON COMMENT '可选参数列表',
    param_templates JSON NOT NULL COMMENT '参数模板定义',
    version VARCHAR(20) DEFAULT '1.0.0',
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_category (category),
    INDEX idx_active (is_active)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='Action定义表';

-- 4. 新增VariableSchemas表管理数据Schema
CREATE TABLE variable_schemas (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    schema_name VARCHAR(255) NOT NULL COMMENT 'Schema名称',
    schema_definition JSON NOT NULL COMMENT 'Schema定义',
    description TEXT COMMENT '描述',
    usage_count INT DEFAULT 0 COMMENT '使用次数',
    created_by VARCHAR(100) COMMENT '创建者',
    is_public BOOLEAN DEFAULT FALSE COMMENT '是否公开',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_schema_name (schema_name),
    INDEX idx_public (is_public),
    INDEX idx_usage (usage_count DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='变量Schema定义表';
```

#### 数据模型类设计
```python
from sqlalchemy import Column, Integer, String, Text, DateTime, Boolean, Enum, JSON
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime
import json

Base = declarative_base()

class ExecutionContext(Base):
    """执行上下文变量模型"""
    __tablename__ = 'execution_contexts'
    
    id = Column(Integer, primary_key=True)
    execution_id = Column(String(50), nullable=False)
    variable_name = Column(String(255), nullable=False)
    variable_value = Column(Text, nullable=False)
    variable_type = Column(Enum('string', 'number', 'boolean', 'object', 'array'), nullable=False)
    source_step_index = Column(Integer, nullable=False)
    extraction_query = Column(Text)
    extraction_schema = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def to_dict(self):
        return {
            'id': self.id,
            'execution_id': self.execution_id,
            'variable_name': self.variable_name,
            'variable_value': json.loads(self.variable_value),
            'variable_type': self.variable_type,
            'source_step_index': self.source_step_index,
            'extraction_query': self.extraction_query,
            'extraction_schema': self.extraction_schema,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None
        }
    
    @classmethod
    def from_dict(cls, data):
        return cls(
            execution_id=data['execution_id'],
            variable_name=data['variable_name'],
            variable_value=json.dumps(data['variable_value']),
            variable_type=data['variable_type'],
            source_step_index=data['source_step_index'],
            extraction_query=data.get('extraction_query'),
            extraction_schema=data.get('extraction_schema')
        )

class ActionDefinition(Base):
    """Action定义模型"""
    __tablename__ = 'action_definitions'
    
    id = Column(String(100), primary_key=True)
    display_name = Column(String(255), nullable=False)
    icon = Column(String(50))
    category = Column(Enum('navigation', 'interaction', 'assertion', 'data', 'control'), nullable=False)
    description = Column(Text)
    required_params = Column(JSON, nullable=False)
    optional_params = Column(JSON)
    param_templates = Column(JSON, nullable=False)
    version = Column(String(20), default='1.0.0')
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def to_dict(self):
        return {
            'id': self.id,
            'display_name': self.display_name,
            'icon': self.icon,
            'category': self.category,
            'description': self.description,
            'required_params': self.required_params,
            'optional_params': self.optional_params,
            'param_templates': self.param_templates,
            'version': self.version,
            'is_active': self.is_active
        }

class VariableSchema(Base):
    """变量Schema定义模型"""
    __tablename__ = 'variable_schemas'
    
    id = Column(Integer, primary_key=True)
    schema_name = Column(String(255), nullable=False, unique=True)
    schema_definition = Column(JSON, nullable=False)
    description = Column(Text)
    usage_count = Column(Integer, default=0)
    created_by = Column(String(100))
    is_public = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def to_dict(self):
        return {
            'id': self.id,
            'schema_name': self.schema_name,
            'schema_definition': self.schema_definition,
            'description': self.description,
            'usage_count': self.usage_count,
            'created_by': self.created_by,
            'is_public': self.is_public,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }
```

### 数据访问层设计

#### Repository模式实现
```python
class ExecutionContextRepository:
    """执行上下文数据访问层"""
    
    def __init__(self, db_session):
        self.db = db_session
    
    def create_variable(self, variable_data: dict) -> ExecutionContext:
        """创建变量记录"""
        context = ExecutionContext.from_dict(variable_data)
        self.db.add(context)
        self.db.commit()
        return context
    
    def get_variable(self, execution_id: str, variable_name: str) -> Optional[ExecutionContext]:
        """获取指定变量"""
        return self.db.query(ExecutionContext).filter(
            ExecutionContext.execution_id == execution_id,
            ExecutionContext.variable_name == variable_name
        ).first()
    
    def get_all_variables(self, execution_id: str) -> List[ExecutionContext]:
        """获取执行上下文中的所有变量"""
        return self.db.query(ExecutionContext).filter(
            ExecutionContext.execution_id == execution_id
        ).order_by(ExecutionContext.source_step_index).all()
    
    def update_variable(self, execution_id: str, variable_name: str, new_value: any) -> bool:
        """更新变量值"""
        context = self.get_variable(execution_id, variable_name)
        if context:
            context.variable_value = json.dumps(new_value)
            context.updated_at = datetime.utcnow()
            self.db.commit()
            return True
        return False
    
    def delete_variable(self, execution_id: str, variable_name: str) -> bool:
        """删除变量"""
        deleted_count = self.db.query(ExecutionContext).filter(
            ExecutionContext.execution_id == execution_id,
            ExecutionContext.variable_name == variable_name
        ).delete()
        self.db.commit()
        return deleted_count > 0
    
    def cleanup_execution_context(self, execution_id: str) -> int:
        """清理执行上下文(执行完成后调用)"""
        deleted_count = self.db.query(ExecutionContext).filter(
            ExecutionContext.execution_id == execution_id
        ).delete()
        self.db.commit()
        return deleted_count
```

### 数据迁移策略

#### 数据库迁移脚本
```python
"""
数据流功能数据库迁移脚本
Migration: add_dataflow_support
"""

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import mysql

def upgrade():
    # 1. 扩展step_executions表
    op.add_column('step_executions', 
        sa.Column('output_data', sa.Text(), nullable=True, comment='步骤输出数据'))
    op.add_column('step_executions', 
        sa.Column('output_variable', sa.String(255), nullable=True, comment='输出变量名'))
    op.add_column('step_executions', 
        sa.Column('output_type', sa.String(50), nullable=True, comment='输出数据类型'))
    op.add_column('step_executions', 
        sa.Column('extraction_query', sa.Text(), nullable=True, comment='数据提取查询'))
    op.add_column('step_executions', 
        sa.Column('extraction_schema', sa.Text(), nullable=True, comment='数据提取Schema'))
    
    # 添加索引
    op.create_index('idx_output_variable', 'step_executions', ['output_variable'])
    op.create_index('idx_execution_variable', 'step_executions', ['execution_id', 'output_variable'])
    
    # 2. 创建execution_contexts表
    op.create_table('execution_contexts',
        sa.Column('id', sa.BigInteger(), nullable=False),
        sa.Column('execution_id', sa.String(50), nullable=False),
        sa.Column('variable_name', sa.String(255), nullable=False),
        sa.Column('variable_value', sa.Text(), nullable=False),
        sa.Column('variable_type', sa.Enum('string', 'number', 'boolean', 'object', 'array'), nullable=False),
        sa.Column('source_step_index', sa.Integer(), nullable=False),
        sa.Column('extraction_query', sa.Text(), nullable=True),
        sa.Column('extraction_schema', sa.Text(), nullable=True),
        sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('updated_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP')),
        sa.ForeignKeyConstraint(['execution_id'], ['execution_history.execution_id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('execution_id', 'variable_name', name='uk_execution_variable'),
        mysql_engine='InnoDB',
        mysql_charset='utf8mb4',
        mysql_comment='执行上下文变量表'
    )
    
    # 创建索引
    op.create_index('idx_execution_id', 'execution_contexts', ['execution_id'])
    op.create_index('idx_variable_name', 'execution_contexts', ['variable_name'])
    op.create_index('idx_variable_type', 'execution_contexts', ['variable_type'])
    op.create_index('idx_source_step', 'execution_contexts', ['source_step_index'])

    # 3. 创建action_definitions表
    op.create_table('action_definitions',
        sa.Column('id', sa.String(100), nullable=False),
        sa.Column('display_name', sa.String(255), nullable=False),
        sa.Column('icon', sa.String(50), nullable=True),
        sa.Column('category', sa.Enum('navigation', 'interaction', 'assertion', 'data', 'control'), nullable=False),
        sa.Column('description', sa.Text(), nullable=True),
        sa.Column('required_params', sa.JSON(), nullable=False),
        sa.Column('optional_params', sa.JSON(), nullable=True),
        sa.Column('param_templates', sa.JSON(), nullable=False),
        sa.Column('version', sa.String(20), server_default='1.0.0'),
        sa.Column('is_active', sa.Boolean(), server_default='1'),
        sa.Column('created_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP')),
        sa.Column('updated_at', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP')),
        sa.PrimaryKeyConstraint('id'),
        mysql_engine='InnoDB',
        mysql_charset='utf8mb4',
        mysql_comment='Action定义表'
    )
    
    op.create_index('idx_category', 'action_definitions', ['category'])
    op.create_index('idx_active', 'action_definitions', ['is_active'])

    # 4. 插入默认Action定义数据
    insert_default_action_definitions()

def downgrade():
    # 删除新增的表
    op.drop_table('execution_contexts')
    op.drop_table('action_definitions')
    
    # 删除step_executions表的新增列
    op.drop_index('idx_execution_variable', 'step_executions')
    op.drop_index('idx_output_variable', 'step_executions')
    op.drop_column('step_executions', 'extraction_schema')
    op.drop_column('step_executions', 'extraction_query')
    op.drop_column('step_executions', 'output_type')
    op.drop_column('step_executions', 'output_variable')
    op.drop_column('step_executions', 'output_data')

def insert_default_action_definitions():
    """插入默认的Action定义数据"""
    from sqlalchemy import text
    
    default_actions = [
        {
            'id': 'ai_extract_string',
            'display_name': '提取字符串',
            'icon': '📝',
            'category': 'data',
            'description': '从页面中提取字符串数据',
            'required_params': ['query', 'output_variable'],
            'optional_params': ['timeout'],
            'param_templates': {
                'query': {
                    'type': 'string',
                    'placeholder': '描述要提取的字符串数据',
                    'support_variables': False,
                    'validation': ['required']
                },
                'output_variable': {
                    'type': 'variable_name',
                    'placeholder': '变量名（如：product_name）',
                    'pattern': '^[a-zA-Z_][a-zA-Z0-9_]*$',
                    'validation': ['required', 'variable_name']
                },
                'timeout': {
                    'type': 'number',
                    'default': 10000,
                    'min': 1000,
                    'max': 60000,
                    'unit': '毫秒'
                }
            }
        },
        # ... 更多默认Action定义
    ]
    
    # 执行插入操作
    # ... 实现数据插入逻辑
```

---

## 🏗️ 基础设施架构

### 云服务架构
```
                    ┌─────────────────┐
                    │   Cloudflare    │
                    │   CDN + WAF     │
                    └─────────┬───────┘
                              │
                    ┌─────────▼───────┐
                    │     Vercel      │
                    │  Frontend Host  │
                    └─────────┬───────┘
                              │
            ┌─────────────────┼─────────────────┐
            │                 │                 │
    ┌───────▼──────┐ ┌───────▼──────┐ ┌───────▼──────┐
    │   Supabase   │ │   Node.js    │ │    Redis     │
    │  PostgreSQL  │ │ MidSceneJS   │ │    Cache     │
    │   Database   │ │   Server     │ │   (Optional) │
    └──────────────┘ └──────────────┘ └──────────────┘
```

### 部署架构设计

#### 1. Vercel无服务器部署
```javascript
// vercel.json配置
{
  "version": 2,
  "builds": [
    {
      "src": "api/index.py",
      "use": "@vercel/python"
    },
    {
      "src": "web_gui/static/**",
      "use": "@vercel/static"
    }
  ],
  "routes": [
    {
      "src": "/api/(.*)",
      "dest": "/api/index.py"
    },
    {
      "src": "/static/(.*)",
      "dest": "/web_gui/static/$1"
    },
    {
      "src": "/(.*)",
      "dest": "/api/index.py"
    }
  ],
  "env": {
    "DATABASE_URL": "@database_url",
    "OPENAI_API_KEY": "@openai_api_key",
    "REDIS_URL": "@redis_url"
  },
  "functions": {
    "api/index.py": {
      "memory": 1024,
      "maxDuration": 30
    }
  }
}
```

#### 2. 本地代理包架构
```
Local Proxy Package
├── midscene_server.js          # MidSceneJS服务器
├── package.json                # 依赖定义
├── start.sh / start.bat        # 启动脚本
├── config/
│   ├── default.json           # 默认配置
│   └── production.json        # 生产配置
├── lib/
│   ├── browser-manager.js     # 浏览器管理
│   ├── cache-manager.js       # 缓存管理
│   └── performance-monitor.js # 性能监控
└── logs/                      # 日志目录
```

#### 3. 数据库架构优化
```sql
-- 分库分表策略
-- 1. 按执行ID hash分表execution_contexts
CREATE TABLE execution_contexts_0 LIKE execution_contexts;
CREATE TABLE execution_contexts_1 LIKE execution_contexts;
-- ... 更多分表

-- 2. 数据归档策略
-- 执行历史数据按月归档
CREATE TABLE execution_history_archive_202501 LIKE execution_history;

-- 3. 读写分离配置
-- 主库：写操作
-- 从库：读操作和报表查询
```

### 监控和可观测性

#### 1. 应用性能监控(APM)
```python
# Sentry错误监控集成
import sentry_sdk
from sentry_sdk.integrations.flask import FlaskIntegration
from sentry_sdk.integrations.sqlalchemy import SqlalchemyIntegration

sentry_sdk.init(
    dsn="YOUR_SENTRY_DSN",
    integrations=[
        FlaskIntegration(transaction_style='endpoint'),
        SqlalchemyIntegration(),
    ],
    traces_sample_rate=0.1,
    environment=os.getenv('ENVIRONMENT', 'development')
)

# 自定义性能指标
from prometheus_client import Counter, Histogram, Gauge

# 变量解析性能指标
variable_resolution_duration = Histogram(
    'variable_resolution_duration_seconds',
    'Time spent resolving variables',
    ['execution_id', 'variable_count']
)

# 数据提取性能指标
data_extraction_duration = Histogram(
    'data_extraction_duration_seconds', 
    'Time spent extracting data',
    ['action_type', 'success']
)

# 智能提示请求计数
suggestion_requests_total = Counter(
    'suggestion_requests_total',
    'Total suggestion requests',
    ['request_type', 'status']
)
```

#### 2. 日志架构设计
```python
import structlog
import logging
from pythonjsonlogger import jsonlogger

# 结构化日志配置
def configure_logging():
    # JSON格式日志输出
    json_handler = logging.StreamHandler()
    formatter = jsonlogger.JsonFormatter(
        '%(asctime)s %(name)s %(levelname)s %(message)s'
    )
    json_handler.setFormatter(formatter)
    
    # 配置不同级别的logger
    loggers = {
        'dataflow': logging.getLogger('dataflow'),
        'variable_resolution': logging.getLogger('variable_resolution'),
        'ai_extraction': logging.getLogger('ai_extraction'),
        'performance': logging.getLogger('performance')
    }
    
    for logger in loggers.values():
        logger.addHandler(json_handler)
        logger.setLevel(logging.INFO)
    
    return loggers

# 使用示例
logger = configure_logging()['dataflow']
logger.info("Variable resolved", 
    extra={
        'execution_id': execution_id,
        'variable_name': variable_name,
        'resolution_time_ms': resolution_time,
        'variable_type': variable_type
    }
)
```

### 安全架构

#### 1. 数据安全策略
```python
from cryptography.fernet import Fernet
import os

class VariableDataEncryption:
    """变量数据加密管理"""
    
    def __init__(self):
        # 从环境变量获取加密密钥
        self.encryption_key = os.getenv('VARIABLE_ENCRYPTION_KEY')
        if not self.encryption_key:
            self.encryption_key = Fernet.generate_key()
        self.cipher_suite = Fernet(self.encryption_key)
    
    def encrypt_variable_data(self, data: dict) -> str:
        """加密变量数据"""
        json_data = json.dumps(data, ensure_ascii=False)
        encrypted_data = self.cipher_suite.encrypt(json_data.encode())
        return encrypted_data.decode()
    
    def decrypt_variable_data(self, encrypted_data: str) -> dict:
        """解密变量数据"""
        decrypted_data = self.cipher_suite.decrypt(encrypted_data.encode())
        return json.loads(decrypted_data.decode())
```

#### 2. API安全防护
```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from functools import wraps
import jwt

# API限流配置
limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["1000 per hour"]
)

# JWT认证装饰器
def require_auth(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        token = request.headers.get('Authorization')
        if not token:
            return jsonify({'error': 'No token provided'}), 401
        
        try:
            payload = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            request.user_id = payload['user_id']
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
        
        return f(*args, **kwargs)
    return decorated_function

# 数据访问权限控制
@app.route('/api/v1/executions/<execution_id>/variables')
@require_auth
@limiter.limit("100 per minute")
def get_execution_variables(execution_id):
    # 验证用户是否有权限访问该执行的变量数据
    if not has_execution_access(request.user_id, execution_id):
        return jsonify({'error': 'Access denied'}), 403
    
    # ... 业务逻辑
```

---

## 🚀 部署和运维架构

### CI/CD流水线设计
```yaml
# .github/workflows/deploy.yml
name: Deploy Intent Test Framework

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
    
    - name: Install Python dependencies
      run: |
        pip install -r requirements.txt
        pip install -r web_gui/requirements.txt
    
    - name: Install Node.js dependencies
      run: npm install
    
    - name: Run Python tests
      run: |
        python -m pytest tests/ -v --cov=web_gui --cov-report=xml
    
    - name: Run Node.js tests
      run: npm test
    
    - name: Run integration tests
      run: |
        python -m pytest tests/integration/ -v
    
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3

  build-frontend:
    needs: test
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
    
    - name: Install dependencies
      run: npm install
    
    - name: Build frontend
      run: npm run build
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: frontend-build
        path: web_gui/static/dist/

  deploy-vercel:
    needs: [test, build-frontend]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        name: frontend-build
        path: web_gui/static/dist/
    
    - name: Deploy to Vercel
      uses: amondnet/vercel-action@v20
      with:
        vercel-token: ${{ secrets.VERCEL_TOKEN }}
        vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
        vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
        vercel-args: '--prod'

  generate-proxy-package:
    needs: [test, build-frontend]
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Package local proxy
      run: |
        mkdir -p proxy-package
        cp midscene_server.js proxy-package/
        cp package.json proxy-package/
        cp -r config/ proxy-package/
        cp -r lib/ proxy-package/
        
        # 创建启动脚本
        cat > proxy-package/start.sh << 'EOF'
        #!/bin/bash
        echo "Starting Intent Test Framework Local Proxy..."
        npm install
        node midscene_server.js
        EOF
        chmod +x proxy-package/start.sh
        
        # 打包
        tar -czf intent-test-proxy-v${{ github.run_number }}.tar.gz proxy-package/
    
    - name: Upload proxy package
      uses: actions/upload-artifact@v3
      with:
        name: proxy-package
        path: intent-test-proxy-v${{ github.run_number }}.tar.gz
```

### 数据库迁移管理
```python
# migrations/管理脚本
import alembic.config
import os

class DatabaseMigrationManager:
    def __init__(self, database_url):
        self.database_url = database_url
        self.alembic_cfg = alembic.config.Config("alembic.ini")
        self.alembic_cfg.set_main_option("sqlalchemy.url", database_url)
    
    def migrate_to_latest(self):
        """迁移到最新版本"""
        from alembic import command
        command.upgrade(self.alembic_cfg, "head")
    
    def create_migration(self, message):
        """创建新的迁移脚本"""
        from alembic import command
        command.revision(self.alembic_cfg, message=message, autogenerate=True)
    
    def rollback_migration(self, revision="-1"):
        """回滚迁移"""
        from alembic import command
        command.downgrade(self.alembic_cfg, revision)
    
    def get_current_revision(self):
        """获取当前数据库版本"""
        from alembic import command
        return command.current(self.alembic_cfg)

# 部署时的数据库初始化脚本
def initialize_database():
    """初始化数据库"""
    migration_manager = DatabaseMigrationManager(os.getenv('DATABASE_URL'))
    
    try:
        # 执行迁移
        migration_manager.migrate_to_latest()
        
        # 初始化基础数据
        initialize_action_definitions()
        initialize_default_schemas()
        
        print("Database initialized successfully")
        
    except Exception as e:
        print(f"Database initialization failed: {e}")
        raise
```

### 性能监控和告警
```python
# monitoring/performance_monitor.py
import time
from functools import wraps
from prometheus_client import start_http_server, Summary, Counter, Histogram

# 性能指标定义
REQUEST_TIME = Summary('request_processing_seconds', 'Time spent processing request')
REQUEST_COUNT = Counter('requests_total', 'Total requests', ['method', 'endpoint', 'status'])
VARIABLE_RESOLUTION_TIME = Histogram('variable_resolution_seconds', 'Variable resolution time')
DATA_EXTRACTION_TIME = Histogram('data_extraction_seconds', 'Data extraction time')

def monitor_performance(metric_name=None):
    """性能监控装饰器"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            start_time = time.time()
            
            try:
                result = f(*args, **kwargs)
                status = 'success'
                return result
            except Exception as e:
                status = 'error'
                raise
            finally:
                duration = time.time() - start_time
                
                # 记录性能指标
                if metric_name == 'variable_resolution':
                    VARIABLE_RESOLUTION_TIME.observe(duration)
                elif metric_name == 'data_extraction':
                    DATA_EXTRACTION_TIME.observe(duration)
                
                # 记录通用请求指标
                REQUEST_TIME.observe(duration)
                REQUEST_COUNT.labels(
                    method=getattr(f, 'method', 'unknown'),
                    endpoint=f.__name__,
                    status=status
                ).inc()
        
        return decorated_function
    return decorator

# 使用示例
@monitor_performance('variable_resolution')
def resolve_variables(text, context):
    # ... 变量解析逻辑
    pass

# 启动监控服务器
def start_monitoring():
    start_http_server(8000)
    print("Performance monitoring started on port 8000")
```

---

## 📈 性能和扩展性架构

### 性能目标和SLA
| 指标 | 目标值 | 测量方式 |
|------|--------|----------|
| 智能提示响应时间 | < 200ms | P95响应时间 |
| 变量解析时间 | < 500ms | 平均处理时间 |
| 数据提取时间 | < 10s | P90响应时间 |
| 并发执行能力 | 100+ | 同时执行的测试用例数 |
| 数据库查询性能 | < 100ms | 平均查询时间 |
| 系统可用性 | 99.9% | 月度可用性 |

### 扩展性架构设计

#### 1. 水平扩展策略
```python
# 数据分片策略
class ExecutionContextSharding:
    def __init__(self):
        self.shard_count = 8
    
    def get_shard_key(self, execution_id: str) -> int:
        """根据执行ID计算分片键"""
        return hash(execution_id) % self.shard_count
    
    def get_table_name(self, execution_id: str) -> str:
        """获取分片表名"""
        shard_key = self.get_shard_key(execution_id)
        return f"execution_contexts_{shard_key}"
    
    def route_query(self, execution_id: str, query_func):
        """路由查询到正确的分片"""
        table_name = self.get_table_name(execution_id)
        return query_func(table_name)

# 读写分离配置
class DatabaseRouter:
    def __init__(self):
        self.master_db = get_master_connection()
        self.slave_dbs = get_slave_connections()
        self.current_slave = 0
    
    def get_read_connection(self):
        """获取读连接（负载均衡）"""
        connection = self.slave_dbs[self.current_slave]
        self.current_slave = (self.current_slave + 1) % len(self.slave_dbs)
        return connection
    
    def get_write_connection(self):
        """获取写连接"""
        return self.master_db
```

#### 2. 缓存架构设计
```python
import redis
from functools import wraps
import pickle
import json

class VariableCacheManager:
    def __init__(self):
        self.redis_client = redis.Redis(
            host=os.getenv('REDIS_HOST', 'localhost'),
            port=int(os.getenv('REDIS_PORT', 6379)),
            db=int(os.getenv('REDIS_DB', 0)),
            decode_responses=False
        )
        self.default_ttl = 3600  # 1小时
    
    def cache_variable(self, execution_id: str, variable_name: str, data: dict, ttl: int = None):
        """缓存变量数据"""
        cache_key = f"var:{execution_id}:{variable_name}"
        serialized_data = pickle.dumps(data)
        self.redis_client.setex(cache_key, ttl or self.default_ttl, serialized_data)
    
    def get_cached_variable(self, execution_id: str, variable_name: str) -> dict:
        """获取缓存的变量数据"""
        cache_key = f"var:{execution_id}:{variable_name}"
        cached_data = self.redis_client.get(cache_key)
        if cached_data:
            return pickle.loads(cached_data)
        return None
    
    def cache_suggestion_data(self, testcase_id: str, suggestions: list, ttl: int = 300):
        """缓存智能提示数据"""
        cache_key = f"suggestions:{testcase_id}"
        self.redis_client.setex(cache_key, ttl, json.dumps(suggestions))
    
    def get_cached_suggestions(self, testcase_id: str) -> list:
        """获取缓存的智能提示数据"""
        cache_key = f"suggestions:{testcase_id}"
        cached_data = self.redis_client.get(cache_key)
        if cached_data:
            return json.loads(cached_data)
        return None

def cache_result(cache_key_func, ttl=3600):
    """缓存装饰器"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            cache_manager = VariableCacheManager()
            cache_key = cache_key_func(*args, **kwargs)
            
            # 尝试从缓存获取
            cached_result = cache_manager.redis_client.get(cache_key)
            if cached_result:
                return pickle.loads(cached_result)
            
            # 执行函数并缓存结果
            result = f(*args, **kwargs)
            serialized_result = pickle.dumps(result)
            cache_manager.redis_client.setex(cache_key, ttl, serialized_result)
            
            return result
        return decorated_function
    return decorator

# 使用示例
@cache_result(lambda testcase_id: f"available_vars:{testcase_id}", ttl=600)
def get_available_variables(testcase_id: str) -> list:
    # ... 数据库查询逻辑
    pass
```

---

## 🔧 开发和测试架构

### 开发环境配置
```yaml
# docker-compose.dev.yml
version: '3.8'

services:
  postgres:
    image: postgres:13
    environment:
      POSTGRES_DB: intent_test_dev
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql

  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  midscene-server:
    build:
      context: .
      dockerfile: Dockerfile.midscene
    ports:
      - "3001:3001"
    environment:
      - NODE_ENV=development
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    volumes:
      - .:/app
      - /app/node_modules

  flask-app:
    build:
      context: .
      dockerfile: Dockerfile.flask
    ports:
      - "5001:5001"
    environment:
      - FLASK_ENV=development
      - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/intent_test_dev
      - REDIS_URL=redis://redis:6379/0
    volumes:
      - .:/app
    depends_on:
      - postgres
      - redis
      - midscene-server

volumes:
  postgres_data:
  redis_data:
```

### 测试架构设计
```python
# tests/conftest.py
import pytest
from unittest.mock import Mock, patch
from web_gui.app_enhanced import create_app
from web_gui.models import db, TestCase, ExecutionHistory
import os

@pytest.fixture(scope='session')
def app():
    """创建测试应用实例"""
    app = create_app({
        'TESTING': True,
        'SQLALCHEMY_DATABASE_URI': 'sqlite:///:memory:',
        'WTF_CSRF_ENABLED': False
    })
    
    with app.app_context():
        db.create_all()
        yield app
        db.drop_all()

@pytest.fixture
def client(app):
    """创建测试客户端"""
    return app.test_client()

@pytest.fixture
def execution_context():
    """模拟执行上下文"""
    from web_gui.services.execution_context import ExecutionContextService
    return ExecutionContextService('test_execution_123')

@pytest.fixture
def mock_midscene_server():
    """模拟MidSceneJS服务器"""
    with patch('requests.post') as mock_post:
        mock_post.return_value.json.return_value = {
            'success': True,
            'data': {'extracted_value': 'test_data'},
            'dataType': 'string'
        }
        yield mock_post

# tests/unit/test_variable_resolver.py
import pytest
from web_gui.services.variable_resolver import VariableResolverService
from web_gui.services.execution_context import ExecutionContextService

class TestVariableResolverService:
    
    def setup_method(self):
        self.execution_context = ExecutionContextService('test_exec_123')
        self.resolver = VariableResolverService(self.execution_context)
        
        # 准备测试数据
        self.execution_context.store_variable(
            'user_info', 
            {'name': 'John', 'age': 30, 'email': 'john@example.com'},
            'object',
            1
        )
        self.execution_context.store_variable('product_price', 99.99, 'number', 2)
    
    def test_simple_variable_resolution(self):
        """测试简单变量解析"""
        text = "User price is ${product_price}"
        resolved = self.resolver.resolve_string_value(text)
        assert resolved == "User price is 99.99"
    
    def test_nested_property_resolution(self):
        """测试嵌套属性解析"""
        text = "User ${user_info.name} with email ${user_info.email}"
        resolved = self.resolver.resolve_string_value(text)
        assert resolved == "User John with email john@example.com"
    
    def test_undefined_variable_error(self):
        """测试未定义变量错误"""
        text = "Invalid ${undefined_var}"
        with pytest.raises(VariableNotFoundError):
            self.resolver.resolve_string_value(text)
    
    def test_invalid_property_error(self):
        """测试无效属性错误"""
        text = "Invalid ${user_info.invalid_property}"
        with pytest.raises(VariablePropertyError):
            self.resolver.resolve_string_value(text)

# tests/integration/test_dataflow_e2e.py
import pytest
import json

class TestDataflowIntegration:
    
    def test_complete_dataflow_workflow(self, client, mock_midscene_server):
        """测试完整的数据流工作流"""
        
        # 1. 创建包含数据提取步骤的测试用例
        testcase_data = {
            'name': '数据流测试用例',
            'description': '测试数据提取和变量引用',
            'steps': [
                {
                    'action': 'navigate',
                    'params': {'url': 'https://example.com'},
                    'description': '访问测试页面'
                },
                {
                    'action': 'ai_extract_object',
                    'params': {
                        'query': '提取用户信息',
                        'data_schema': '{"name": "string", "age": "number"}',
                        'output_variable': 'user_data'
                    },
                    'description': '提取用户数据'
                },
                {
                    'action': 'ai_input',
                    'params': {
                        'text': 'Hello ${user_data.name}',
                        'locate': '消息输入框'
                    },
                    'description': '使用提取的用户名'
                }
            ]
        }
        
        # 创建测试用例
        response = client.post('/api/v1/testcases/', 
                             data=json.dumps(testcase_data),
                             content_type='application/json')
        assert response.status_code == 201
        testcase_id = response.json['data']['id']
        
        # 2. 执行测试用例
        response = client.post(f'/api/v1/testcases/{testcase_id}/execute',
                             data=json.dumps({'mode': 'headless'}),
                             content_type='application/json')
        assert response.status_code == 200
        execution_id = response.json['data']['execution_id']
        
        # 3. 验证变量数据被正确存储
        response = client.get(f'/api/v1/executions/{execution_id}/variables')
        assert response.status_code == 200
        variables = response.json['data']
        
        # 验证用户数据变量存在
        user_data_var = next((v for v in variables if v['variable_name'] == 'user_data'), None)
        assert user_data_var is not None
        assert user_data_var['variable_type'] == 'object'
        
        # 4. 验证变量引用被正确解析
        # 通过查看步骤执行历史验证变量替换
        response = client.get(f'/api/v1/executions/{execution_id}/steps')
        assert response.status_code == 200
        step_executions = response.json['data']
        
        # 找到第三个步骤（使用变量的步骤）
        input_step = next((s for s in step_executions if s['step_index'] == 2), None)
        assert input_step is not None
        # 验证参数中的变量已被解析
        # 这里需要根据实际的执行结果验证
    
    def test_variable_validation_api(self, client):
        """测试变量验证API"""
        
        # 创建带有变量引用的步骤
        step_data = {
            'action': 'ai_input',
            'params': {
                'text': 'Hello ${user_name} and ${user_age}',
                'locate': 'input field'
            }
        }
        
        # 可用变量列表
        available_variables = ['user_name', 'user_email']  # 注意：user_age不在可用列表中
        
        # 验证步骤
        response = client.post('/api/v1/steps/validate',
                             data=json.dumps({
                                 'step': step_data,
                                 'available_variables': available_variables
                             }),
                             content_type='application/json')
        
        assert response.status_code == 200
        validation_result = response.json['data']
        
        # 应该有一个错误：user_age变量未定义
        assert len(validation_result['errors']) == 1
        assert 'user_age' in validation_result['errors'][0]
    
    def test_intelligent_suggestions_api(self, client):
        """测试智能提示API"""
        
        # 创建一个包含变量的测试用例
        testcase_data = {
            'name': '测试用例',
            'steps': [
                {
                    'action': 'ai_extract_string',
                    'params': {
                        'query': '提取产品名称',
                        'output_variable': 'product_name'
                    }
                },
                {
                    'action': 'ai_extract_number', 
                    'params': {
                        'query': '提取产品价格',
                        'output_variable': 'product_price'
                    }
                }
            ]
        }
        
        response = client.post('/api/v1/testcases/',
                             data=json.dumps(testcase_data),
                             content_type='application/json')
        testcase_id = response.json['data']['id']
        
        # 获取变量建议
        response = client.get(f'/api/v1/testcases/{testcase_id}/variable-suggestions')
        assert response.status_code == 200
        
        suggestions = response.json['data']
        assert len(suggestions) == 2
        
        # 验证建议包含正确的变量信息
        product_name_suggestion = next((s for s in suggestions if s['name'] == 'product_name'), None)
        assert product_name_suggestion is not None
        assert product_name_suggestion['type'] == 'string'
        assert product_name_suggestion['source_step'] == 1
```

---

## 📚 总结与建议

### 架构亮点
1. **渐进式架构**: 在现有系统基础上平滑扩展，保持向后兼容性
2. **用户体验驱动**: 智能提示和表单化配置显著提升易用性
3. **性能优化**: 多层缓存和异步处理确保系统响应性能
4. **安全可靠**: 完整的数据加密、权限控制和错误处理机制
5. **可扩展架构**: 支持水平扩展和功能模块化扩展

### 实施建议

#### 短期实施重点（1-2个月）
1. **核心数据流功能**: 优先实现变量解析和数据提取功能
2. **智能提示系统**: 重点优化用户输入体验
3. **数据库迁移**: 安全可靠的数据模型升级

#### 中期优化目标（3-6个月）
1. **性能调优**: 基于真实使用数据进行性能优化
2. **用户反馈迭代**: 根据用户使用情况优化功能设计
3. **扩展功能**: 实现高级数据操作和可视化功能

#### 长期发展方向（6-12个月）
1. **AI增强**: 集成更先进的AI能力提升自动化程度
2. **企业级功能**: 多租户、权限管理、审计日志等
3. **生态建设**: 插件系统、第三方集成、社区模板

### 风险评估与缓解

#### 技术风险
- **风险**: MidSceneJS API变更影响集成
- **缓解**: 版本锁定和适配层设计

#### 性能风险  
- **风险**: 大量变量处理影响系统性能
- **缓解**: 分层缓存和异步处理架构

#### 兼容性风险
- **风险**: 新功能影响现有测试用例
- **缓解**: 完整的向后兼容性测试和渐进式发布

### 成功关键因素
1. **团队协作**: 前后端、AI引擎团队的紧密配合
2. **用户参与**: 持续的用户反馈和需求验证
3. **质量保证**: 完善的测试覆盖和质量门禁
4. **监控体系**: 全面的性能监控和用户行为分析

这个全栈架构设计为Intent Test Framework的数据流功能提供了完整的技术实现路径，既保证了功能的完整性和先进性，又确保了系统的稳定性和可维护性。通过分阶段实施，可以在控制风险的同时逐步释放价值，最终实现用户体验的显著提升。

---

*本架构文档将随着项目进展持续更新和完善。如有任何技术问题或架构疑问，请及时沟通讨论。*